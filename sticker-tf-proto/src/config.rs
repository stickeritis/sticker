// This file is generated by rust-protobuf 2.7.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `tensorflow/core/protobuf/config.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_7_0;

#[derive(PartialEq,Clone,Default)]
pub struct GPUOptions {
    // message fields
    pub per_process_gpu_memory_fraction: f64,
    pub allow_growth: bool,
    pub allocator_type: ::std::string::String,
    pub deferred_deletion_bytes: i64,
    pub visible_device_list: ::std::string::String,
    pub polling_active_delay_usecs: i32,
    pub polling_inactive_delay_msecs: i32,
    pub force_gpu_compatible: bool,
    pub experimental: ::protobuf::SingularPtrField<GPUOptions_Experimental>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GPUOptions {
    fn default() -> &'a GPUOptions {
        <GPUOptions as ::protobuf::Message>::default_instance()
    }
}

impl GPUOptions {
    pub fn new() -> GPUOptions {
        ::std::default::Default::default()
    }

    // double per_process_gpu_memory_fraction = 1;


    pub fn get_per_process_gpu_memory_fraction(&self) -> f64 {
        self.per_process_gpu_memory_fraction
    }
    pub fn clear_per_process_gpu_memory_fraction(&mut self) {
        self.per_process_gpu_memory_fraction = 0.;
    }

    // Param is passed by value, moved
    pub fn set_per_process_gpu_memory_fraction(&mut self, v: f64) {
        self.per_process_gpu_memory_fraction = v;
    }

    // bool allow_growth = 4;


    pub fn get_allow_growth(&self) -> bool {
        self.allow_growth
    }
    pub fn clear_allow_growth(&mut self) {
        self.allow_growth = false;
    }

    // Param is passed by value, moved
    pub fn set_allow_growth(&mut self, v: bool) {
        self.allow_growth = v;
    }

    // string allocator_type = 2;


    pub fn get_allocator_type(&self) -> &str {
        &self.allocator_type
    }
    pub fn clear_allocator_type(&mut self) {
        self.allocator_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_allocator_type(&mut self, v: ::std::string::String) {
        self.allocator_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_allocator_type(&mut self) -> &mut ::std::string::String {
        &mut self.allocator_type
    }

    // Take field
    pub fn take_allocator_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.allocator_type, ::std::string::String::new())
    }

    // int64 deferred_deletion_bytes = 3;


    pub fn get_deferred_deletion_bytes(&self) -> i64 {
        self.deferred_deletion_bytes
    }
    pub fn clear_deferred_deletion_bytes(&mut self) {
        self.deferred_deletion_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_deferred_deletion_bytes(&mut self, v: i64) {
        self.deferred_deletion_bytes = v;
    }

    // string visible_device_list = 5;


    pub fn get_visible_device_list(&self) -> &str {
        &self.visible_device_list
    }
    pub fn clear_visible_device_list(&mut self) {
        self.visible_device_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_visible_device_list(&mut self, v: ::std::string::String) {
        self.visible_device_list = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_visible_device_list(&mut self) -> &mut ::std::string::String {
        &mut self.visible_device_list
    }

    // Take field
    pub fn take_visible_device_list(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.visible_device_list, ::std::string::String::new())
    }

    // int32 polling_active_delay_usecs = 6;


    pub fn get_polling_active_delay_usecs(&self) -> i32 {
        self.polling_active_delay_usecs
    }
    pub fn clear_polling_active_delay_usecs(&mut self) {
        self.polling_active_delay_usecs = 0;
    }

    // Param is passed by value, moved
    pub fn set_polling_active_delay_usecs(&mut self, v: i32) {
        self.polling_active_delay_usecs = v;
    }

    // int32 polling_inactive_delay_msecs = 7;


    pub fn get_polling_inactive_delay_msecs(&self) -> i32 {
        self.polling_inactive_delay_msecs
    }
    pub fn clear_polling_inactive_delay_msecs(&mut self) {
        self.polling_inactive_delay_msecs = 0;
    }

    // Param is passed by value, moved
    pub fn set_polling_inactive_delay_msecs(&mut self, v: i32) {
        self.polling_inactive_delay_msecs = v;
    }

    // bool force_gpu_compatible = 8;


    pub fn get_force_gpu_compatible(&self) -> bool {
        self.force_gpu_compatible
    }
    pub fn clear_force_gpu_compatible(&mut self) {
        self.force_gpu_compatible = false;
    }

    // Param is passed by value, moved
    pub fn set_force_gpu_compatible(&mut self, v: bool) {
        self.force_gpu_compatible = v;
    }

    // .tensorflow.GPUOptions.Experimental experimental = 9;


    pub fn get_experimental(&self) -> &GPUOptions_Experimental {
        self.experimental.as_ref().unwrap_or_else(|| GPUOptions_Experimental::default_instance())
    }
    pub fn clear_experimental(&mut self) {
        self.experimental.clear();
    }

    pub fn has_experimental(&self) -> bool {
        self.experimental.is_some()
    }

    // Param is passed by value, moved
    pub fn set_experimental(&mut self, v: GPUOptions_Experimental) {
        self.experimental = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_experimental(&mut self) -> &mut GPUOptions_Experimental {
        if self.experimental.is_none() {
            self.experimental.set_default();
        }
        self.experimental.as_mut().unwrap()
    }

    // Take field
    pub fn take_experimental(&mut self) -> GPUOptions_Experimental {
        self.experimental.take().unwrap_or_else(|| GPUOptions_Experimental::new())
    }
}

impl ::protobuf::Message for GPUOptions {
    fn is_initialized(&self) -> bool {
        for v in &self.experimental {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.per_process_gpu_memory_fraction = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allow_growth = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.allocator_type)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.deferred_deletion_bytes = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.visible_device_list)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.polling_active_delay_usecs = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.polling_inactive_delay_msecs = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.force_gpu_compatible = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.experimental)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.per_process_gpu_memory_fraction != 0. {
            my_size += 9;
        }
        if self.allow_growth != false {
            my_size += 2;
        }
        if !self.allocator_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.allocator_type);
        }
        if self.deferred_deletion_bytes != 0 {
            my_size += ::protobuf::rt::value_size(3, self.deferred_deletion_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.visible_device_list.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.visible_device_list);
        }
        if self.polling_active_delay_usecs != 0 {
            my_size += ::protobuf::rt::value_size(6, self.polling_active_delay_usecs, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.polling_inactive_delay_msecs != 0 {
            my_size += ::protobuf::rt::value_size(7, self.polling_inactive_delay_msecs, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.force_gpu_compatible != false {
            my_size += 2;
        }
        if let Some(ref v) = self.experimental.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.per_process_gpu_memory_fraction != 0. {
            os.write_double(1, self.per_process_gpu_memory_fraction)?;
        }
        if self.allow_growth != false {
            os.write_bool(4, self.allow_growth)?;
        }
        if !self.allocator_type.is_empty() {
            os.write_string(2, &self.allocator_type)?;
        }
        if self.deferred_deletion_bytes != 0 {
            os.write_int64(3, self.deferred_deletion_bytes)?;
        }
        if !self.visible_device_list.is_empty() {
            os.write_string(5, &self.visible_device_list)?;
        }
        if self.polling_active_delay_usecs != 0 {
            os.write_int32(6, self.polling_active_delay_usecs)?;
        }
        if self.polling_inactive_delay_msecs != 0 {
            os.write_int32(7, self.polling_inactive_delay_msecs)?;
        }
        if self.force_gpu_compatible != false {
            os.write_bool(8, self.force_gpu_compatible)?;
        }
        if let Some(ref v) = self.experimental.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GPUOptions {
        GPUOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "per_process_gpu_memory_fraction",
                    |m: &GPUOptions| { &m.per_process_gpu_memory_fraction },
                    |m: &mut GPUOptions| { &mut m.per_process_gpu_memory_fraction },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "allow_growth",
                    |m: &GPUOptions| { &m.allow_growth },
                    |m: &mut GPUOptions| { &mut m.allow_growth },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "allocator_type",
                    |m: &GPUOptions| { &m.allocator_type },
                    |m: &mut GPUOptions| { &mut m.allocator_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "deferred_deletion_bytes",
                    |m: &GPUOptions| { &m.deferred_deletion_bytes },
                    |m: &mut GPUOptions| { &mut m.deferred_deletion_bytes },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "visible_device_list",
                    |m: &GPUOptions| { &m.visible_device_list },
                    |m: &mut GPUOptions| { &mut m.visible_device_list },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "polling_active_delay_usecs",
                    |m: &GPUOptions| { &m.polling_active_delay_usecs },
                    |m: &mut GPUOptions| { &mut m.polling_active_delay_usecs },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "polling_inactive_delay_msecs",
                    |m: &GPUOptions| { &m.polling_inactive_delay_msecs },
                    |m: &mut GPUOptions| { &mut m.polling_inactive_delay_msecs },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "force_gpu_compatible",
                    |m: &GPUOptions| { &m.force_gpu_compatible },
                    |m: &mut GPUOptions| { &mut m.force_gpu_compatible },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GPUOptions_Experimental>>(
                    "experimental",
                    |m: &GPUOptions| { &m.experimental },
                    |m: &mut GPUOptions| { &mut m.experimental },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GPUOptions>(
                    "GPUOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GPUOptions {
        static mut instance: ::protobuf::lazy::Lazy<GPUOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GPUOptions,
        };
        unsafe {
            instance.get(GPUOptions::new)
        }
    }
}

impl ::protobuf::Clear for GPUOptions {
    fn clear(&mut self) {
        self.per_process_gpu_memory_fraction = 0.;
        self.allow_growth = false;
        self.allocator_type.clear();
        self.deferred_deletion_bytes = 0;
        self.visible_device_list.clear();
        self.polling_active_delay_usecs = 0;
        self.polling_inactive_delay_msecs = 0;
        self.force_gpu_compatible = false;
        self.experimental.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GPUOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GPUOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GPUOptions_Experimental {
    // message fields
    pub virtual_devices: ::protobuf::RepeatedField<GPUOptions_Experimental_VirtualDevices>,
    pub use_unified_memory: bool,
    pub num_dev_to_dev_copy_streams: i32,
    pub collective_ring_order: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GPUOptions_Experimental {
    fn default() -> &'a GPUOptions_Experimental {
        <GPUOptions_Experimental as ::protobuf::Message>::default_instance()
    }
}

impl GPUOptions_Experimental {
    pub fn new() -> GPUOptions_Experimental {
        ::std::default::Default::default()
    }

    // repeated .tensorflow.GPUOptions.Experimental.VirtualDevices virtual_devices = 1;


    pub fn get_virtual_devices(&self) -> &[GPUOptions_Experimental_VirtualDevices] {
        &self.virtual_devices
    }
    pub fn clear_virtual_devices(&mut self) {
        self.virtual_devices.clear();
    }

    // Param is passed by value, moved
    pub fn set_virtual_devices(&mut self, v: ::protobuf::RepeatedField<GPUOptions_Experimental_VirtualDevices>) {
        self.virtual_devices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_virtual_devices(&mut self) -> &mut ::protobuf::RepeatedField<GPUOptions_Experimental_VirtualDevices> {
        &mut self.virtual_devices
    }

    // Take field
    pub fn take_virtual_devices(&mut self) -> ::protobuf::RepeatedField<GPUOptions_Experimental_VirtualDevices> {
        ::std::mem::replace(&mut self.virtual_devices, ::protobuf::RepeatedField::new())
    }

    // bool use_unified_memory = 2;


    pub fn get_use_unified_memory(&self) -> bool {
        self.use_unified_memory
    }
    pub fn clear_use_unified_memory(&mut self) {
        self.use_unified_memory = false;
    }

    // Param is passed by value, moved
    pub fn set_use_unified_memory(&mut self, v: bool) {
        self.use_unified_memory = v;
    }

    // int32 num_dev_to_dev_copy_streams = 3;


    pub fn get_num_dev_to_dev_copy_streams(&self) -> i32 {
        self.num_dev_to_dev_copy_streams
    }
    pub fn clear_num_dev_to_dev_copy_streams(&mut self) {
        self.num_dev_to_dev_copy_streams = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_dev_to_dev_copy_streams(&mut self, v: i32) {
        self.num_dev_to_dev_copy_streams = v;
    }

    // string collective_ring_order = 4;


    pub fn get_collective_ring_order(&self) -> &str {
        &self.collective_ring_order
    }
    pub fn clear_collective_ring_order(&mut self) {
        self.collective_ring_order.clear();
    }

    // Param is passed by value, moved
    pub fn set_collective_ring_order(&mut self, v: ::std::string::String) {
        self.collective_ring_order = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_collective_ring_order(&mut self) -> &mut ::std::string::String {
        &mut self.collective_ring_order
    }

    // Take field
    pub fn take_collective_ring_order(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.collective_ring_order, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GPUOptions_Experimental {
    fn is_initialized(&self) -> bool {
        for v in &self.virtual_devices {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.virtual_devices)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_unified_memory = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_dev_to_dev_copy_streams = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.collective_ring_order)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.virtual_devices {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.use_unified_memory != false {
            my_size += 2;
        }
        if self.num_dev_to_dev_copy_streams != 0 {
            my_size += ::protobuf::rt::value_size(3, self.num_dev_to_dev_copy_streams, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.collective_ring_order.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.collective_ring_order);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.virtual_devices {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.use_unified_memory != false {
            os.write_bool(2, self.use_unified_memory)?;
        }
        if self.num_dev_to_dev_copy_streams != 0 {
            os.write_int32(3, self.num_dev_to_dev_copy_streams)?;
        }
        if !self.collective_ring_order.is_empty() {
            os.write_string(4, &self.collective_ring_order)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GPUOptions_Experimental {
        GPUOptions_Experimental::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GPUOptions_Experimental_VirtualDevices>>(
                    "virtual_devices",
                    |m: &GPUOptions_Experimental| { &m.virtual_devices },
                    |m: &mut GPUOptions_Experimental| { &mut m.virtual_devices },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "use_unified_memory",
                    |m: &GPUOptions_Experimental| { &m.use_unified_memory },
                    |m: &mut GPUOptions_Experimental| { &mut m.use_unified_memory },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "num_dev_to_dev_copy_streams",
                    |m: &GPUOptions_Experimental| { &m.num_dev_to_dev_copy_streams },
                    |m: &mut GPUOptions_Experimental| { &mut m.num_dev_to_dev_copy_streams },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "collective_ring_order",
                    |m: &GPUOptions_Experimental| { &m.collective_ring_order },
                    |m: &mut GPUOptions_Experimental| { &mut m.collective_ring_order },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GPUOptions_Experimental>(
                    "GPUOptions_Experimental",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GPUOptions_Experimental {
        static mut instance: ::protobuf::lazy::Lazy<GPUOptions_Experimental> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GPUOptions_Experimental,
        };
        unsafe {
            instance.get(GPUOptions_Experimental::new)
        }
    }
}

impl ::protobuf::Clear for GPUOptions_Experimental {
    fn clear(&mut self) {
        self.virtual_devices.clear();
        self.use_unified_memory = false;
        self.num_dev_to_dev_copy_streams = 0;
        self.collective_ring_order.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GPUOptions_Experimental {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GPUOptions_Experimental {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GPUOptions_Experimental_VirtualDevices {
    // message fields
    pub memory_limit_mb: ::std::vec::Vec<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GPUOptions_Experimental_VirtualDevices {
    fn default() -> &'a GPUOptions_Experimental_VirtualDevices {
        <GPUOptions_Experimental_VirtualDevices as ::protobuf::Message>::default_instance()
    }
}

impl GPUOptions_Experimental_VirtualDevices {
    pub fn new() -> GPUOptions_Experimental_VirtualDevices {
        ::std::default::Default::default()
    }

    // repeated float memory_limit_mb = 1;


    pub fn get_memory_limit_mb(&self) -> &[f32] {
        &self.memory_limit_mb
    }
    pub fn clear_memory_limit_mb(&mut self) {
        self.memory_limit_mb.clear();
    }

    // Param is passed by value, moved
    pub fn set_memory_limit_mb(&mut self, v: ::std::vec::Vec<f32>) {
        self.memory_limit_mb = v;
    }

    // Mutable pointer to the field.
    pub fn mut_memory_limit_mb(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.memory_limit_mb
    }

    // Take field
    pub fn take_memory_limit_mb(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.memory_limit_mb, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GPUOptions_Experimental_VirtualDevices {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.memory_limit_mb)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += 5 * self.memory_limit_mb.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.memory_limit_mb {
            os.write_float(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GPUOptions_Experimental_VirtualDevices {
        GPUOptions_Experimental_VirtualDevices::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "memory_limit_mb",
                    |m: &GPUOptions_Experimental_VirtualDevices| { &m.memory_limit_mb },
                    |m: &mut GPUOptions_Experimental_VirtualDevices| { &mut m.memory_limit_mb },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GPUOptions_Experimental_VirtualDevices>(
                    "GPUOptions_Experimental_VirtualDevices",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GPUOptions_Experimental_VirtualDevices {
        static mut instance: ::protobuf::lazy::Lazy<GPUOptions_Experimental_VirtualDevices> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GPUOptions_Experimental_VirtualDevices,
        };
        unsafe {
            instance.get(GPUOptions_Experimental_VirtualDevices::new)
        }
    }
}

impl ::protobuf::Clear for GPUOptions_Experimental_VirtualDevices {
    fn clear(&mut self) {
        self.memory_limit_mb.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GPUOptions_Experimental_VirtualDevices {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GPUOptions_Experimental_VirtualDevices {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OptimizerOptions {
    // message fields
    pub do_common_subexpression_elimination: bool,
    pub do_constant_folding: bool,
    pub max_folded_constant_in_bytes: i64,
    pub do_function_inlining: bool,
    pub opt_level: OptimizerOptions_Level,
    pub global_jit_level: OptimizerOptions_GlobalJitLevel,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OptimizerOptions {
    fn default() -> &'a OptimizerOptions {
        <OptimizerOptions as ::protobuf::Message>::default_instance()
    }
}

impl OptimizerOptions {
    pub fn new() -> OptimizerOptions {
        ::std::default::Default::default()
    }

    // bool do_common_subexpression_elimination = 1;


    pub fn get_do_common_subexpression_elimination(&self) -> bool {
        self.do_common_subexpression_elimination
    }
    pub fn clear_do_common_subexpression_elimination(&mut self) {
        self.do_common_subexpression_elimination = false;
    }

    // Param is passed by value, moved
    pub fn set_do_common_subexpression_elimination(&mut self, v: bool) {
        self.do_common_subexpression_elimination = v;
    }

    // bool do_constant_folding = 2;


    pub fn get_do_constant_folding(&self) -> bool {
        self.do_constant_folding
    }
    pub fn clear_do_constant_folding(&mut self) {
        self.do_constant_folding = false;
    }

    // Param is passed by value, moved
    pub fn set_do_constant_folding(&mut self, v: bool) {
        self.do_constant_folding = v;
    }

    // int64 max_folded_constant_in_bytes = 6;


    pub fn get_max_folded_constant_in_bytes(&self) -> i64 {
        self.max_folded_constant_in_bytes
    }
    pub fn clear_max_folded_constant_in_bytes(&mut self) {
        self.max_folded_constant_in_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_folded_constant_in_bytes(&mut self, v: i64) {
        self.max_folded_constant_in_bytes = v;
    }

    // bool do_function_inlining = 4;


    pub fn get_do_function_inlining(&self) -> bool {
        self.do_function_inlining
    }
    pub fn clear_do_function_inlining(&mut self) {
        self.do_function_inlining = false;
    }

    // Param is passed by value, moved
    pub fn set_do_function_inlining(&mut self, v: bool) {
        self.do_function_inlining = v;
    }

    // .tensorflow.OptimizerOptions.Level opt_level = 3;


    pub fn get_opt_level(&self) -> OptimizerOptions_Level {
        self.opt_level
    }
    pub fn clear_opt_level(&mut self) {
        self.opt_level = OptimizerOptions_Level::L1;
    }

    // Param is passed by value, moved
    pub fn set_opt_level(&mut self, v: OptimizerOptions_Level) {
        self.opt_level = v;
    }

    // .tensorflow.OptimizerOptions.GlobalJitLevel global_jit_level = 5;


    pub fn get_global_jit_level(&self) -> OptimizerOptions_GlobalJitLevel {
        self.global_jit_level
    }
    pub fn clear_global_jit_level(&mut self) {
        self.global_jit_level = OptimizerOptions_GlobalJitLevel::DEFAULT;
    }

    // Param is passed by value, moved
    pub fn set_global_jit_level(&mut self, v: OptimizerOptions_GlobalJitLevel) {
        self.global_jit_level = v;
    }
}

impl ::protobuf::Message for OptimizerOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.do_common_subexpression_elimination = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.do_constant_folding = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.max_folded_constant_in_bytes = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.do_function_inlining = tmp;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.opt_level, 3, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.global_jit_level, 5, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.do_common_subexpression_elimination != false {
            my_size += 2;
        }
        if self.do_constant_folding != false {
            my_size += 2;
        }
        if self.max_folded_constant_in_bytes != 0 {
            my_size += ::protobuf::rt::value_size(6, self.max_folded_constant_in_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.do_function_inlining != false {
            my_size += 2;
        }
        if self.opt_level != OptimizerOptions_Level::L1 {
            my_size += ::protobuf::rt::enum_size(3, self.opt_level);
        }
        if self.global_jit_level != OptimizerOptions_GlobalJitLevel::DEFAULT {
            my_size += ::protobuf::rt::enum_size(5, self.global_jit_level);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.do_common_subexpression_elimination != false {
            os.write_bool(1, self.do_common_subexpression_elimination)?;
        }
        if self.do_constant_folding != false {
            os.write_bool(2, self.do_constant_folding)?;
        }
        if self.max_folded_constant_in_bytes != 0 {
            os.write_int64(6, self.max_folded_constant_in_bytes)?;
        }
        if self.do_function_inlining != false {
            os.write_bool(4, self.do_function_inlining)?;
        }
        if self.opt_level != OptimizerOptions_Level::L1 {
            os.write_enum(3, self.opt_level.value())?;
        }
        if self.global_jit_level != OptimizerOptions_GlobalJitLevel::DEFAULT {
            os.write_enum(5, self.global_jit_level.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OptimizerOptions {
        OptimizerOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "do_common_subexpression_elimination",
                    |m: &OptimizerOptions| { &m.do_common_subexpression_elimination },
                    |m: &mut OptimizerOptions| { &mut m.do_common_subexpression_elimination },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "do_constant_folding",
                    |m: &OptimizerOptions| { &m.do_constant_folding },
                    |m: &mut OptimizerOptions| { &mut m.do_constant_folding },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "max_folded_constant_in_bytes",
                    |m: &OptimizerOptions| { &m.max_folded_constant_in_bytes },
                    |m: &mut OptimizerOptions| { &mut m.max_folded_constant_in_bytes },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "do_function_inlining",
                    |m: &OptimizerOptions| { &m.do_function_inlining },
                    |m: &mut OptimizerOptions| { &mut m.do_function_inlining },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OptimizerOptions_Level>>(
                    "opt_level",
                    |m: &OptimizerOptions| { &m.opt_level },
                    |m: &mut OptimizerOptions| { &mut m.opt_level },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OptimizerOptions_GlobalJitLevel>>(
                    "global_jit_level",
                    |m: &OptimizerOptions| { &m.global_jit_level },
                    |m: &mut OptimizerOptions| { &mut m.global_jit_level },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OptimizerOptions>(
                    "OptimizerOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OptimizerOptions {
        static mut instance: ::protobuf::lazy::Lazy<OptimizerOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OptimizerOptions,
        };
        unsafe {
            instance.get(OptimizerOptions::new)
        }
    }
}

impl ::protobuf::Clear for OptimizerOptions {
    fn clear(&mut self) {
        self.do_common_subexpression_elimination = false;
        self.do_constant_folding = false;
        self.max_folded_constant_in_bytes = 0;
        self.do_function_inlining = false;
        self.opt_level = OptimizerOptions_Level::L1;
        self.global_jit_level = OptimizerOptions_GlobalJitLevel::DEFAULT;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OptimizerOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OptimizerOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OptimizerOptions_Level {
    L1 = 0,
    L0 = -1,
}

impl ::protobuf::ProtobufEnum for OptimizerOptions_Level {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OptimizerOptions_Level> {
        match value {
            0 => ::std::option::Option::Some(OptimizerOptions_Level::L1),
            -1 => ::std::option::Option::Some(OptimizerOptions_Level::L0),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OptimizerOptions_Level] = &[
            OptimizerOptions_Level::L1,
            OptimizerOptions_Level::L0,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("OptimizerOptions_Level", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for OptimizerOptions_Level {
}

impl ::std::default::Default for OptimizerOptions_Level {
    fn default() -> Self {
        OptimizerOptions_Level::L1
    }
}

impl ::protobuf::reflect::ProtobufValue for OptimizerOptions_Level {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OptimizerOptions_GlobalJitLevel {
    DEFAULT = 0,
    OFF = -1,
    ON_1 = 1,
    ON_2 = 2,
}

impl ::protobuf::ProtobufEnum for OptimizerOptions_GlobalJitLevel {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OptimizerOptions_GlobalJitLevel> {
        match value {
            0 => ::std::option::Option::Some(OptimizerOptions_GlobalJitLevel::DEFAULT),
            -1 => ::std::option::Option::Some(OptimizerOptions_GlobalJitLevel::OFF),
            1 => ::std::option::Option::Some(OptimizerOptions_GlobalJitLevel::ON_1),
            2 => ::std::option::Option::Some(OptimizerOptions_GlobalJitLevel::ON_2),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OptimizerOptions_GlobalJitLevel] = &[
            OptimizerOptions_GlobalJitLevel::DEFAULT,
            OptimizerOptions_GlobalJitLevel::OFF,
            OptimizerOptions_GlobalJitLevel::ON_1,
            OptimizerOptions_GlobalJitLevel::ON_2,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("OptimizerOptions_GlobalJitLevel", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for OptimizerOptions_GlobalJitLevel {
}

impl ::std::default::Default for OptimizerOptions_GlobalJitLevel {
    fn default() -> Self {
        OptimizerOptions_GlobalJitLevel::DEFAULT
    }
}

impl ::protobuf::reflect::ProtobufValue for OptimizerOptions_GlobalJitLevel {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GraphOptions {
    // message fields
    pub enable_recv_scheduling: bool,
    pub optimizer_options: ::protobuf::SingularPtrField<OptimizerOptions>,
    pub build_cost_model: i64,
    pub build_cost_model_after: i64,
    pub infer_shapes: bool,
    pub place_pruned_graph: bool,
    pub enable_bfloat16_sendrecv: bool,
    pub timeline_step: i32,
    pub rewrite_options: ::protobuf::SingularPtrField<super::rewriter_config::RewriterConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GraphOptions {
    fn default() -> &'a GraphOptions {
        <GraphOptions as ::protobuf::Message>::default_instance()
    }
}

impl GraphOptions {
    pub fn new() -> GraphOptions {
        ::std::default::Default::default()
    }

    // bool enable_recv_scheduling = 2;


    pub fn get_enable_recv_scheduling(&self) -> bool {
        self.enable_recv_scheduling
    }
    pub fn clear_enable_recv_scheduling(&mut self) {
        self.enable_recv_scheduling = false;
    }

    // Param is passed by value, moved
    pub fn set_enable_recv_scheduling(&mut self, v: bool) {
        self.enable_recv_scheduling = v;
    }

    // .tensorflow.OptimizerOptions optimizer_options = 3;


    pub fn get_optimizer_options(&self) -> &OptimizerOptions {
        self.optimizer_options.as_ref().unwrap_or_else(|| OptimizerOptions::default_instance())
    }
    pub fn clear_optimizer_options(&mut self) {
        self.optimizer_options.clear();
    }

    pub fn has_optimizer_options(&self) -> bool {
        self.optimizer_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optimizer_options(&mut self, v: OptimizerOptions) {
        self.optimizer_options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_optimizer_options(&mut self) -> &mut OptimizerOptions {
        if self.optimizer_options.is_none() {
            self.optimizer_options.set_default();
        }
        self.optimizer_options.as_mut().unwrap()
    }

    // Take field
    pub fn take_optimizer_options(&mut self) -> OptimizerOptions {
        self.optimizer_options.take().unwrap_or_else(|| OptimizerOptions::new())
    }

    // int64 build_cost_model = 4;


    pub fn get_build_cost_model(&self) -> i64 {
        self.build_cost_model
    }
    pub fn clear_build_cost_model(&mut self) {
        self.build_cost_model = 0;
    }

    // Param is passed by value, moved
    pub fn set_build_cost_model(&mut self, v: i64) {
        self.build_cost_model = v;
    }

    // int64 build_cost_model_after = 9;


    pub fn get_build_cost_model_after(&self) -> i64 {
        self.build_cost_model_after
    }
    pub fn clear_build_cost_model_after(&mut self) {
        self.build_cost_model_after = 0;
    }

    // Param is passed by value, moved
    pub fn set_build_cost_model_after(&mut self, v: i64) {
        self.build_cost_model_after = v;
    }

    // bool infer_shapes = 5;


    pub fn get_infer_shapes(&self) -> bool {
        self.infer_shapes
    }
    pub fn clear_infer_shapes(&mut self) {
        self.infer_shapes = false;
    }

    // Param is passed by value, moved
    pub fn set_infer_shapes(&mut self, v: bool) {
        self.infer_shapes = v;
    }

    // bool place_pruned_graph = 6;


    pub fn get_place_pruned_graph(&self) -> bool {
        self.place_pruned_graph
    }
    pub fn clear_place_pruned_graph(&mut self) {
        self.place_pruned_graph = false;
    }

    // Param is passed by value, moved
    pub fn set_place_pruned_graph(&mut self, v: bool) {
        self.place_pruned_graph = v;
    }

    // bool enable_bfloat16_sendrecv = 7;


    pub fn get_enable_bfloat16_sendrecv(&self) -> bool {
        self.enable_bfloat16_sendrecv
    }
    pub fn clear_enable_bfloat16_sendrecv(&mut self) {
        self.enable_bfloat16_sendrecv = false;
    }

    // Param is passed by value, moved
    pub fn set_enable_bfloat16_sendrecv(&mut self, v: bool) {
        self.enable_bfloat16_sendrecv = v;
    }

    // int32 timeline_step = 8;


    pub fn get_timeline_step(&self) -> i32 {
        self.timeline_step
    }
    pub fn clear_timeline_step(&mut self) {
        self.timeline_step = 0;
    }

    // Param is passed by value, moved
    pub fn set_timeline_step(&mut self, v: i32) {
        self.timeline_step = v;
    }

    // .tensorflow.RewriterConfig rewrite_options = 10;


    pub fn get_rewrite_options(&self) -> &super::rewriter_config::RewriterConfig {
        self.rewrite_options.as_ref().unwrap_or_else(|| super::rewriter_config::RewriterConfig::default_instance())
    }
    pub fn clear_rewrite_options(&mut self) {
        self.rewrite_options.clear();
    }

    pub fn has_rewrite_options(&self) -> bool {
        self.rewrite_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rewrite_options(&mut self, v: super::rewriter_config::RewriterConfig) {
        self.rewrite_options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rewrite_options(&mut self) -> &mut super::rewriter_config::RewriterConfig {
        if self.rewrite_options.is_none() {
            self.rewrite_options.set_default();
        }
        self.rewrite_options.as_mut().unwrap()
    }

    // Take field
    pub fn take_rewrite_options(&mut self) -> super::rewriter_config::RewriterConfig {
        self.rewrite_options.take().unwrap_or_else(|| super::rewriter_config::RewriterConfig::new())
    }
}

impl ::protobuf::Message for GraphOptions {
    fn is_initialized(&self) -> bool {
        for v in &self.optimizer_options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rewrite_options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_recv_scheduling = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.optimizer_options)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.build_cost_model = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.build_cost_model_after = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.infer_shapes = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.place_pruned_graph = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_bfloat16_sendrecv = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.timeline_step = tmp;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rewrite_options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.enable_recv_scheduling != false {
            my_size += 2;
        }
        if let Some(ref v) = self.optimizer_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.build_cost_model != 0 {
            my_size += ::protobuf::rt::value_size(4, self.build_cost_model, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.build_cost_model_after != 0 {
            my_size += ::protobuf::rt::value_size(9, self.build_cost_model_after, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.infer_shapes != false {
            my_size += 2;
        }
        if self.place_pruned_graph != false {
            my_size += 2;
        }
        if self.enable_bfloat16_sendrecv != false {
            my_size += 2;
        }
        if self.timeline_step != 0 {
            my_size += ::protobuf::rt::value_size(8, self.timeline_step, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.rewrite_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.enable_recv_scheduling != false {
            os.write_bool(2, self.enable_recv_scheduling)?;
        }
        if let Some(ref v) = self.optimizer_options.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.build_cost_model != 0 {
            os.write_int64(4, self.build_cost_model)?;
        }
        if self.build_cost_model_after != 0 {
            os.write_int64(9, self.build_cost_model_after)?;
        }
        if self.infer_shapes != false {
            os.write_bool(5, self.infer_shapes)?;
        }
        if self.place_pruned_graph != false {
            os.write_bool(6, self.place_pruned_graph)?;
        }
        if self.enable_bfloat16_sendrecv != false {
            os.write_bool(7, self.enable_bfloat16_sendrecv)?;
        }
        if self.timeline_step != 0 {
            os.write_int32(8, self.timeline_step)?;
        }
        if let Some(ref v) = self.rewrite_options.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GraphOptions {
        GraphOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "enable_recv_scheduling",
                    |m: &GraphOptions| { &m.enable_recv_scheduling },
                    |m: &mut GraphOptions| { &mut m.enable_recv_scheduling },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OptimizerOptions>>(
                    "optimizer_options",
                    |m: &GraphOptions| { &m.optimizer_options },
                    |m: &mut GraphOptions| { &mut m.optimizer_options },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "build_cost_model",
                    |m: &GraphOptions| { &m.build_cost_model },
                    |m: &mut GraphOptions| { &mut m.build_cost_model },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "build_cost_model_after",
                    |m: &GraphOptions| { &m.build_cost_model_after },
                    |m: &mut GraphOptions| { &mut m.build_cost_model_after },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "infer_shapes",
                    |m: &GraphOptions| { &m.infer_shapes },
                    |m: &mut GraphOptions| { &mut m.infer_shapes },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "place_pruned_graph",
                    |m: &GraphOptions| { &m.place_pruned_graph },
                    |m: &mut GraphOptions| { &mut m.place_pruned_graph },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "enable_bfloat16_sendrecv",
                    |m: &GraphOptions| { &m.enable_bfloat16_sendrecv },
                    |m: &mut GraphOptions| { &mut m.enable_bfloat16_sendrecv },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "timeline_step",
                    |m: &GraphOptions| { &m.timeline_step },
                    |m: &mut GraphOptions| { &mut m.timeline_step },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::rewriter_config::RewriterConfig>>(
                    "rewrite_options",
                    |m: &GraphOptions| { &m.rewrite_options },
                    |m: &mut GraphOptions| { &mut m.rewrite_options },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GraphOptions>(
                    "GraphOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GraphOptions {
        static mut instance: ::protobuf::lazy::Lazy<GraphOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GraphOptions,
        };
        unsafe {
            instance.get(GraphOptions::new)
        }
    }
}

impl ::protobuf::Clear for GraphOptions {
    fn clear(&mut self) {
        self.enable_recv_scheduling = false;
        self.optimizer_options.clear();
        self.build_cost_model = 0;
        self.build_cost_model_after = 0;
        self.infer_shapes = false;
        self.place_pruned_graph = false;
        self.enable_bfloat16_sendrecv = false;
        self.timeline_step = 0;
        self.rewrite_options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GraphOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GraphOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ThreadPoolOptionProto {
    // message fields
    pub num_threads: i32,
    pub global_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ThreadPoolOptionProto {
    fn default() -> &'a ThreadPoolOptionProto {
        <ThreadPoolOptionProto as ::protobuf::Message>::default_instance()
    }
}

impl ThreadPoolOptionProto {
    pub fn new() -> ThreadPoolOptionProto {
        ::std::default::Default::default()
    }

    // int32 num_threads = 1;


    pub fn get_num_threads(&self) -> i32 {
        self.num_threads
    }
    pub fn clear_num_threads(&mut self) {
        self.num_threads = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_threads(&mut self, v: i32) {
        self.num_threads = v;
    }

    // string global_name = 2;


    pub fn get_global_name(&self) -> &str {
        &self.global_name
    }
    pub fn clear_global_name(&mut self) {
        self.global_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_global_name(&mut self, v: ::std::string::String) {
        self.global_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_global_name(&mut self) -> &mut ::std::string::String {
        &mut self.global_name
    }

    // Take field
    pub fn take_global_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.global_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ThreadPoolOptionProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_threads = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.global_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.num_threads != 0 {
            my_size += ::protobuf::rt::value_size(1, self.num_threads, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.global_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.global_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.num_threads != 0 {
            os.write_int32(1, self.num_threads)?;
        }
        if !self.global_name.is_empty() {
            os.write_string(2, &self.global_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ThreadPoolOptionProto {
        ThreadPoolOptionProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "num_threads",
                    |m: &ThreadPoolOptionProto| { &m.num_threads },
                    |m: &mut ThreadPoolOptionProto| { &mut m.num_threads },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "global_name",
                    |m: &ThreadPoolOptionProto| { &m.global_name },
                    |m: &mut ThreadPoolOptionProto| { &mut m.global_name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ThreadPoolOptionProto>(
                    "ThreadPoolOptionProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ThreadPoolOptionProto {
        static mut instance: ::protobuf::lazy::Lazy<ThreadPoolOptionProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ThreadPoolOptionProto,
        };
        unsafe {
            instance.get(ThreadPoolOptionProto::new)
        }
    }
}

impl ::protobuf::Clear for ThreadPoolOptionProto {
    fn clear(&mut self) {
        self.num_threads = 0;
        self.global_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ThreadPoolOptionProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ThreadPoolOptionProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RPCOptions {
    // message fields
    pub use_rpc_for_inprocess_master: bool,
    pub compression_algorithm: ::std::string::String,
    pub compression_level: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RPCOptions {
    fn default() -> &'a RPCOptions {
        <RPCOptions as ::protobuf::Message>::default_instance()
    }
}

impl RPCOptions {
    pub fn new() -> RPCOptions {
        ::std::default::Default::default()
    }

    // bool use_rpc_for_inprocess_master = 1;


    pub fn get_use_rpc_for_inprocess_master(&self) -> bool {
        self.use_rpc_for_inprocess_master
    }
    pub fn clear_use_rpc_for_inprocess_master(&mut self) {
        self.use_rpc_for_inprocess_master = false;
    }

    // Param is passed by value, moved
    pub fn set_use_rpc_for_inprocess_master(&mut self, v: bool) {
        self.use_rpc_for_inprocess_master = v;
    }

    // string compression_algorithm = 2;


    pub fn get_compression_algorithm(&self) -> &str {
        &self.compression_algorithm
    }
    pub fn clear_compression_algorithm(&mut self) {
        self.compression_algorithm.clear();
    }

    // Param is passed by value, moved
    pub fn set_compression_algorithm(&mut self, v: ::std::string::String) {
        self.compression_algorithm = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_compression_algorithm(&mut self) -> &mut ::std::string::String {
        &mut self.compression_algorithm
    }

    // Take field
    pub fn take_compression_algorithm(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.compression_algorithm, ::std::string::String::new())
    }

    // int32 compression_level = 3;


    pub fn get_compression_level(&self) -> i32 {
        self.compression_level
    }
    pub fn clear_compression_level(&mut self) {
        self.compression_level = 0;
    }

    // Param is passed by value, moved
    pub fn set_compression_level(&mut self, v: i32) {
        self.compression_level = v;
    }
}

impl ::protobuf::Message for RPCOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_rpc_for_inprocess_master = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.compression_algorithm)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.compression_level = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.use_rpc_for_inprocess_master != false {
            my_size += 2;
        }
        if !self.compression_algorithm.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.compression_algorithm);
        }
        if self.compression_level != 0 {
            my_size += ::protobuf::rt::value_size(3, self.compression_level, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.use_rpc_for_inprocess_master != false {
            os.write_bool(1, self.use_rpc_for_inprocess_master)?;
        }
        if !self.compression_algorithm.is_empty() {
            os.write_string(2, &self.compression_algorithm)?;
        }
        if self.compression_level != 0 {
            os.write_int32(3, self.compression_level)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RPCOptions {
        RPCOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "use_rpc_for_inprocess_master",
                    |m: &RPCOptions| { &m.use_rpc_for_inprocess_master },
                    |m: &mut RPCOptions| { &mut m.use_rpc_for_inprocess_master },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "compression_algorithm",
                    |m: &RPCOptions| { &m.compression_algorithm },
                    |m: &mut RPCOptions| { &mut m.compression_algorithm },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "compression_level",
                    |m: &RPCOptions| { &m.compression_level },
                    |m: &mut RPCOptions| { &mut m.compression_level },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RPCOptions>(
                    "RPCOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RPCOptions {
        static mut instance: ::protobuf::lazy::Lazy<RPCOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RPCOptions,
        };
        unsafe {
            instance.get(RPCOptions::new)
        }
    }
}

impl ::protobuf::Clear for RPCOptions {
    fn clear(&mut self) {
        self.use_rpc_for_inprocess_master = false;
        self.compression_algorithm.clear();
        self.compression_level = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RPCOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RPCOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConfigProto {
    // message fields
    pub device_count: ::std::collections::HashMap<::std::string::String, i32>,
    pub intra_op_parallelism_threads: i32,
    pub inter_op_parallelism_threads: i32,
    pub use_per_session_threads: bool,
    pub session_inter_op_thread_pool: ::protobuf::RepeatedField<ThreadPoolOptionProto>,
    pub placement_period: i32,
    pub device_filters: ::protobuf::RepeatedField<::std::string::String>,
    pub gpu_options: ::protobuf::SingularPtrField<GPUOptions>,
    pub allow_soft_placement: bool,
    pub log_device_placement: bool,
    pub graph_options: ::protobuf::SingularPtrField<GraphOptions>,
    pub operation_timeout_in_ms: i64,
    pub rpc_options: ::protobuf::SingularPtrField<RPCOptions>,
    pub cluster_def: ::protobuf::SingularPtrField<super::cluster::ClusterDef>,
    pub isolate_session_state: bool,
    pub experimental: ::protobuf::SingularPtrField<ConfigProto_Experimental>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConfigProto {
    fn default() -> &'a ConfigProto {
        <ConfigProto as ::protobuf::Message>::default_instance()
    }
}

impl ConfigProto {
    pub fn new() -> ConfigProto {
        ::std::default::Default::default()
    }

    // repeated .tensorflow.ConfigProto.DeviceCountEntry device_count = 1;


    pub fn get_device_count(&self) -> &::std::collections::HashMap<::std::string::String, i32> {
        &self.device_count
    }
    pub fn clear_device_count(&mut self) {
        self.device_count.clear();
    }

    // Param is passed by value, moved
    pub fn set_device_count(&mut self, v: ::std::collections::HashMap<::std::string::String, i32>) {
        self.device_count = v;
    }

    // Mutable pointer to the field.
    pub fn mut_device_count(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i32> {
        &mut self.device_count
    }

    // Take field
    pub fn take_device_count(&mut self) -> ::std::collections::HashMap<::std::string::String, i32> {
        ::std::mem::replace(&mut self.device_count, ::std::collections::HashMap::new())
    }

    // int32 intra_op_parallelism_threads = 2;


    pub fn get_intra_op_parallelism_threads(&self) -> i32 {
        self.intra_op_parallelism_threads
    }
    pub fn clear_intra_op_parallelism_threads(&mut self) {
        self.intra_op_parallelism_threads = 0;
    }

    // Param is passed by value, moved
    pub fn set_intra_op_parallelism_threads(&mut self, v: i32) {
        self.intra_op_parallelism_threads = v;
    }

    // int32 inter_op_parallelism_threads = 5;


    pub fn get_inter_op_parallelism_threads(&self) -> i32 {
        self.inter_op_parallelism_threads
    }
    pub fn clear_inter_op_parallelism_threads(&mut self) {
        self.inter_op_parallelism_threads = 0;
    }

    // Param is passed by value, moved
    pub fn set_inter_op_parallelism_threads(&mut self, v: i32) {
        self.inter_op_parallelism_threads = v;
    }

    // bool use_per_session_threads = 9;


    pub fn get_use_per_session_threads(&self) -> bool {
        self.use_per_session_threads
    }
    pub fn clear_use_per_session_threads(&mut self) {
        self.use_per_session_threads = false;
    }

    // Param is passed by value, moved
    pub fn set_use_per_session_threads(&mut self, v: bool) {
        self.use_per_session_threads = v;
    }

    // repeated .tensorflow.ThreadPoolOptionProto session_inter_op_thread_pool = 12;


    pub fn get_session_inter_op_thread_pool(&self) -> &[ThreadPoolOptionProto] {
        &self.session_inter_op_thread_pool
    }
    pub fn clear_session_inter_op_thread_pool(&mut self) {
        self.session_inter_op_thread_pool.clear();
    }

    // Param is passed by value, moved
    pub fn set_session_inter_op_thread_pool(&mut self, v: ::protobuf::RepeatedField<ThreadPoolOptionProto>) {
        self.session_inter_op_thread_pool = v;
    }

    // Mutable pointer to the field.
    pub fn mut_session_inter_op_thread_pool(&mut self) -> &mut ::protobuf::RepeatedField<ThreadPoolOptionProto> {
        &mut self.session_inter_op_thread_pool
    }

    // Take field
    pub fn take_session_inter_op_thread_pool(&mut self) -> ::protobuf::RepeatedField<ThreadPoolOptionProto> {
        ::std::mem::replace(&mut self.session_inter_op_thread_pool, ::protobuf::RepeatedField::new())
    }

    // int32 placement_period = 3;


    pub fn get_placement_period(&self) -> i32 {
        self.placement_period
    }
    pub fn clear_placement_period(&mut self) {
        self.placement_period = 0;
    }

    // Param is passed by value, moved
    pub fn set_placement_period(&mut self, v: i32) {
        self.placement_period = v;
    }

    // repeated string device_filters = 4;


    pub fn get_device_filters(&self) -> &[::std::string::String] {
        &self.device_filters
    }
    pub fn clear_device_filters(&mut self) {
        self.device_filters.clear();
    }

    // Param is passed by value, moved
    pub fn set_device_filters(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.device_filters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_device_filters(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.device_filters
    }

    // Take field
    pub fn take_device_filters(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.device_filters, ::protobuf::RepeatedField::new())
    }

    // .tensorflow.GPUOptions gpu_options = 6;


    pub fn get_gpu_options(&self) -> &GPUOptions {
        self.gpu_options.as_ref().unwrap_or_else(|| GPUOptions::default_instance())
    }
    pub fn clear_gpu_options(&mut self) {
        self.gpu_options.clear();
    }

    pub fn has_gpu_options(&self) -> bool {
        self.gpu_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpu_options(&mut self, v: GPUOptions) {
        self.gpu_options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gpu_options(&mut self) -> &mut GPUOptions {
        if self.gpu_options.is_none() {
            self.gpu_options.set_default();
        }
        self.gpu_options.as_mut().unwrap()
    }

    // Take field
    pub fn take_gpu_options(&mut self) -> GPUOptions {
        self.gpu_options.take().unwrap_or_else(|| GPUOptions::new())
    }

    // bool allow_soft_placement = 7;


    pub fn get_allow_soft_placement(&self) -> bool {
        self.allow_soft_placement
    }
    pub fn clear_allow_soft_placement(&mut self) {
        self.allow_soft_placement = false;
    }

    // Param is passed by value, moved
    pub fn set_allow_soft_placement(&mut self, v: bool) {
        self.allow_soft_placement = v;
    }

    // bool log_device_placement = 8;


    pub fn get_log_device_placement(&self) -> bool {
        self.log_device_placement
    }
    pub fn clear_log_device_placement(&mut self) {
        self.log_device_placement = false;
    }

    // Param is passed by value, moved
    pub fn set_log_device_placement(&mut self, v: bool) {
        self.log_device_placement = v;
    }

    // .tensorflow.GraphOptions graph_options = 10;


    pub fn get_graph_options(&self) -> &GraphOptions {
        self.graph_options.as_ref().unwrap_or_else(|| GraphOptions::default_instance())
    }
    pub fn clear_graph_options(&mut self) {
        self.graph_options.clear();
    }

    pub fn has_graph_options(&self) -> bool {
        self.graph_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_graph_options(&mut self, v: GraphOptions) {
        self.graph_options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_graph_options(&mut self) -> &mut GraphOptions {
        if self.graph_options.is_none() {
            self.graph_options.set_default();
        }
        self.graph_options.as_mut().unwrap()
    }

    // Take field
    pub fn take_graph_options(&mut self) -> GraphOptions {
        self.graph_options.take().unwrap_or_else(|| GraphOptions::new())
    }

    // int64 operation_timeout_in_ms = 11;


    pub fn get_operation_timeout_in_ms(&self) -> i64 {
        self.operation_timeout_in_ms
    }
    pub fn clear_operation_timeout_in_ms(&mut self) {
        self.operation_timeout_in_ms = 0;
    }

    // Param is passed by value, moved
    pub fn set_operation_timeout_in_ms(&mut self, v: i64) {
        self.operation_timeout_in_ms = v;
    }

    // .tensorflow.RPCOptions rpc_options = 13;


    pub fn get_rpc_options(&self) -> &RPCOptions {
        self.rpc_options.as_ref().unwrap_or_else(|| RPCOptions::default_instance())
    }
    pub fn clear_rpc_options(&mut self) {
        self.rpc_options.clear();
    }

    pub fn has_rpc_options(&self) -> bool {
        self.rpc_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpc_options(&mut self, v: RPCOptions) {
        self.rpc_options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rpc_options(&mut self) -> &mut RPCOptions {
        if self.rpc_options.is_none() {
            self.rpc_options.set_default();
        }
        self.rpc_options.as_mut().unwrap()
    }

    // Take field
    pub fn take_rpc_options(&mut self) -> RPCOptions {
        self.rpc_options.take().unwrap_or_else(|| RPCOptions::new())
    }

    // .tensorflow.ClusterDef cluster_def = 14;


    pub fn get_cluster_def(&self) -> &super::cluster::ClusterDef {
        self.cluster_def.as_ref().unwrap_or_else(|| super::cluster::ClusterDef::default_instance())
    }
    pub fn clear_cluster_def(&mut self) {
        self.cluster_def.clear();
    }

    pub fn has_cluster_def(&self) -> bool {
        self.cluster_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cluster_def(&mut self, v: super::cluster::ClusterDef) {
        self.cluster_def = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster_def(&mut self) -> &mut super::cluster::ClusterDef {
        if self.cluster_def.is_none() {
            self.cluster_def.set_default();
        }
        self.cluster_def.as_mut().unwrap()
    }

    // Take field
    pub fn take_cluster_def(&mut self) -> super::cluster::ClusterDef {
        self.cluster_def.take().unwrap_or_else(|| super::cluster::ClusterDef::new())
    }

    // bool isolate_session_state = 15;


    pub fn get_isolate_session_state(&self) -> bool {
        self.isolate_session_state
    }
    pub fn clear_isolate_session_state(&mut self) {
        self.isolate_session_state = false;
    }

    // Param is passed by value, moved
    pub fn set_isolate_session_state(&mut self, v: bool) {
        self.isolate_session_state = v;
    }

    // .tensorflow.ConfigProto.Experimental experimental = 16;


    pub fn get_experimental(&self) -> &ConfigProto_Experimental {
        self.experimental.as_ref().unwrap_or_else(|| ConfigProto_Experimental::default_instance())
    }
    pub fn clear_experimental(&mut self) {
        self.experimental.clear();
    }

    pub fn has_experimental(&self) -> bool {
        self.experimental.is_some()
    }

    // Param is passed by value, moved
    pub fn set_experimental(&mut self, v: ConfigProto_Experimental) {
        self.experimental = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_experimental(&mut self) -> &mut ConfigProto_Experimental {
        if self.experimental.is_none() {
            self.experimental.set_default();
        }
        self.experimental.as_mut().unwrap()
    }

    // Take field
    pub fn take_experimental(&mut self) -> ConfigProto_Experimental {
        self.experimental.take().unwrap_or_else(|| ConfigProto_Experimental::new())
    }
}

impl ::protobuf::Message for ConfigProto {
    fn is_initialized(&self) -> bool {
        for v in &self.session_inter_op_thread_pool {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.gpu_options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.graph_options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rpc_options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cluster_def {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.experimental {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(wire_type, is, &mut self.device_count)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.intra_op_parallelism_threads = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.inter_op_parallelism_threads = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_per_session_threads = tmp;
                },
                12 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.session_inter_op_thread_pool)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.placement_period = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.device_filters)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.gpu_options)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allow_soft_placement = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.log_device_placement = tmp;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.graph_options)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.operation_timeout_in_ms = tmp;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rpc_options)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cluster_def)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isolate_session_state = tmp;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.experimental)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(1, &self.device_count);
        if self.intra_op_parallelism_threads != 0 {
            my_size += ::protobuf::rt::value_size(2, self.intra_op_parallelism_threads, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.inter_op_parallelism_threads != 0 {
            my_size += ::protobuf::rt::value_size(5, self.inter_op_parallelism_threads, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.use_per_session_threads != false {
            my_size += 2;
        }
        for value in &self.session_inter_op_thread_pool {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.placement_period != 0 {
            my_size += ::protobuf::rt::value_size(3, self.placement_period, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.device_filters {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let Some(ref v) = self.gpu_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.allow_soft_placement != false {
            my_size += 2;
        }
        if self.log_device_placement != false {
            my_size += 2;
        }
        if let Some(ref v) = self.graph_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.operation_timeout_in_ms != 0 {
            my_size += ::protobuf::rt::value_size(11, self.operation_timeout_in_ms, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.rpc_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cluster_def.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.isolate_session_state != false {
            my_size += 2;
        }
        if let Some(ref v) = self.experimental.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(1, &self.device_count, os)?;
        if self.intra_op_parallelism_threads != 0 {
            os.write_int32(2, self.intra_op_parallelism_threads)?;
        }
        if self.inter_op_parallelism_threads != 0 {
            os.write_int32(5, self.inter_op_parallelism_threads)?;
        }
        if self.use_per_session_threads != false {
            os.write_bool(9, self.use_per_session_threads)?;
        }
        for v in &self.session_inter_op_thread_pool {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.placement_period != 0 {
            os.write_int32(3, self.placement_period)?;
        }
        for v in &self.device_filters {
            os.write_string(4, &v)?;
        };
        if let Some(ref v) = self.gpu_options.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.allow_soft_placement != false {
            os.write_bool(7, self.allow_soft_placement)?;
        }
        if self.log_device_placement != false {
            os.write_bool(8, self.log_device_placement)?;
        }
        if let Some(ref v) = self.graph_options.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.operation_timeout_in_ms != 0 {
            os.write_int64(11, self.operation_timeout_in_ms)?;
        }
        if let Some(ref v) = self.rpc_options.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cluster_def.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.isolate_session_state != false {
            os.write_bool(15, self.isolate_session_state)?;
        }
        if let Some(ref v) = self.experimental.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConfigProto {
        ConfigProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(
                    "device_count",
                    |m: &ConfigProto| { &m.device_count },
                    |m: &mut ConfigProto| { &mut m.device_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "intra_op_parallelism_threads",
                    |m: &ConfigProto| { &m.intra_op_parallelism_threads },
                    |m: &mut ConfigProto| { &mut m.intra_op_parallelism_threads },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "inter_op_parallelism_threads",
                    |m: &ConfigProto| { &m.inter_op_parallelism_threads },
                    |m: &mut ConfigProto| { &mut m.inter_op_parallelism_threads },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "use_per_session_threads",
                    |m: &ConfigProto| { &m.use_per_session_threads },
                    |m: &mut ConfigProto| { &mut m.use_per_session_threads },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ThreadPoolOptionProto>>(
                    "session_inter_op_thread_pool",
                    |m: &ConfigProto| { &m.session_inter_op_thread_pool },
                    |m: &mut ConfigProto| { &mut m.session_inter_op_thread_pool },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "placement_period",
                    |m: &ConfigProto| { &m.placement_period },
                    |m: &mut ConfigProto| { &mut m.placement_period },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "device_filters",
                    |m: &ConfigProto| { &m.device_filters },
                    |m: &mut ConfigProto| { &mut m.device_filters },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GPUOptions>>(
                    "gpu_options",
                    |m: &ConfigProto| { &m.gpu_options },
                    |m: &mut ConfigProto| { &mut m.gpu_options },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "allow_soft_placement",
                    |m: &ConfigProto| { &m.allow_soft_placement },
                    |m: &mut ConfigProto| { &mut m.allow_soft_placement },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "log_device_placement",
                    |m: &ConfigProto| { &m.log_device_placement },
                    |m: &mut ConfigProto| { &mut m.log_device_placement },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GraphOptions>>(
                    "graph_options",
                    |m: &ConfigProto| { &m.graph_options },
                    |m: &mut ConfigProto| { &mut m.graph_options },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "operation_timeout_in_ms",
                    |m: &ConfigProto| { &m.operation_timeout_in_ms },
                    |m: &mut ConfigProto| { &mut m.operation_timeout_in_ms },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RPCOptions>>(
                    "rpc_options",
                    |m: &ConfigProto| { &m.rpc_options },
                    |m: &mut ConfigProto| { &mut m.rpc_options },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::cluster::ClusterDef>>(
                    "cluster_def",
                    |m: &ConfigProto| { &m.cluster_def },
                    |m: &mut ConfigProto| { &mut m.cluster_def },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "isolate_session_state",
                    |m: &ConfigProto| { &m.isolate_session_state },
                    |m: &mut ConfigProto| { &mut m.isolate_session_state },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConfigProto_Experimental>>(
                    "experimental",
                    |m: &ConfigProto| { &m.experimental },
                    |m: &mut ConfigProto| { &mut m.experimental },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConfigProto>(
                    "ConfigProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConfigProto {
        static mut instance: ::protobuf::lazy::Lazy<ConfigProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConfigProto,
        };
        unsafe {
            instance.get(ConfigProto::new)
        }
    }
}

impl ::protobuf::Clear for ConfigProto {
    fn clear(&mut self) {
        self.device_count.clear();
        self.intra_op_parallelism_threads = 0;
        self.inter_op_parallelism_threads = 0;
        self.use_per_session_threads = false;
        self.session_inter_op_thread_pool.clear();
        self.placement_period = 0;
        self.device_filters.clear();
        self.gpu_options.clear();
        self.allow_soft_placement = false;
        self.log_device_placement = false;
        self.graph_options.clear();
        self.operation_timeout_in_ms = 0;
        self.rpc_options.clear();
        self.cluster_def.clear();
        self.isolate_session_state = false;
        self.experimental.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfigProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConfigProto_Experimental {
    // message fields
    pub collective_group_leader: ::std::string::String,
    pub executor_type: ::std::string::String,
    pub recv_buf_max_chunk: i32,
    pub use_numa_affinity: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConfigProto_Experimental {
    fn default() -> &'a ConfigProto_Experimental {
        <ConfigProto_Experimental as ::protobuf::Message>::default_instance()
    }
}

impl ConfigProto_Experimental {
    pub fn new() -> ConfigProto_Experimental {
        ::std::default::Default::default()
    }

    // string collective_group_leader = 1;


    pub fn get_collective_group_leader(&self) -> &str {
        &self.collective_group_leader
    }
    pub fn clear_collective_group_leader(&mut self) {
        self.collective_group_leader.clear();
    }

    // Param is passed by value, moved
    pub fn set_collective_group_leader(&mut self, v: ::std::string::String) {
        self.collective_group_leader = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_collective_group_leader(&mut self) -> &mut ::std::string::String {
        &mut self.collective_group_leader
    }

    // Take field
    pub fn take_collective_group_leader(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.collective_group_leader, ::std::string::String::new())
    }

    // string executor_type = 3;


    pub fn get_executor_type(&self) -> &str {
        &self.executor_type
    }
    pub fn clear_executor_type(&mut self) {
        self.executor_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_executor_type(&mut self, v: ::std::string::String) {
        self.executor_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_executor_type(&mut self) -> &mut ::std::string::String {
        &mut self.executor_type
    }

    // Take field
    pub fn take_executor_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.executor_type, ::std::string::String::new())
    }

    // int32 recv_buf_max_chunk = 4;


    pub fn get_recv_buf_max_chunk(&self) -> i32 {
        self.recv_buf_max_chunk
    }
    pub fn clear_recv_buf_max_chunk(&mut self) {
        self.recv_buf_max_chunk = 0;
    }

    // Param is passed by value, moved
    pub fn set_recv_buf_max_chunk(&mut self, v: i32) {
        self.recv_buf_max_chunk = v;
    }

    // bool use_numa_affinity = 5;


    pub fn get_use_numa_affinity(&self) -> bool {
        self.use_numa_affinity
    }
    pub fn clear_use_numa_affinity(&mut self) {
        self.use_numa_affinity = false;
    }

    // Param is passed by value, moved
    pub fn set_use_numa_affinity(&mut self, v: bool) {
        self.use_numa_affinity = v;
    }
}

impl ::protobuf::Message for ConfigProto_Experimental {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.collective_group_leader)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.executor_type)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.recv_buf_max_chunk = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_numa_affinity = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.collective_group_leader.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.collective_group_leader);
        }
        if !self.executor_type.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.executor_type);
        }
        if self.recv_buf_max_chunk != 0 {
            my_size += ::protobuf::rt::value_size(4, self.recv_buf_max_chunk, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.use_numa_affinity != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.collective_group_leader.is_empty() {
            os.write_string(1, &self.collective_group_leader)?;
        }
        if !self.executor_type.is_empty() {
            os.write_string(3, &self.executor_type)?;
        }
        if self.recv_buf_max_chunk != 0 {
            os.write_int32(4, self.recv_buf_max_chunk)?;
        }
        if self.use_numa_affinity != false {
            os.write_bool(5, self.use_numa_affinity)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConfigProto_Experimental {
        ConfigProto_Experimental::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "collective_group_leader",
                    |m: &ConfigProto_Experimental| { &m.collective_group_leader },
                    |m: &mut ConfigProto_Experimental| { &mut m.collective_group_leader },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "executor_type",
                    |m: &ConfigProto_Experimental| { &m.executor_type },
                    |m: &mut ConfigProto_Experimental| { &mut m.executor_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "recv_buf_max_chunk",
                    |m: &ConfigProto_Experimental| { &m.recv_buf_max_chunk },
                    |m: &mut ConfigProto_Experimental| { &mut m.recv_buf_max_chunk },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "use_numa_affinity",
                    |m: &ConfigProto_Experimental| { &m.use_numa_affinity },
                    |m: &mut ConfigProto_Experimental| { &mut m.use_numa_affinity },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConfigProto_Experimental>(
                    "ConfigProto_Experimental",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConfigProto_Experimental {
        static mut instance: ::protobuf::lazy::Lazy<ConfigProto_Experimental> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConfigProto_Experimental,
        };
        unsafe {
            instance.get(ConfigProto_Experimental::new)
        }
    }
}

impl ::protobuf::Clear for ConfigProto_Experimental {
    fn clear(&mut self) {
        self.collective_group_leader.clear();
        self.executor_type.clear();
        self.recv_buf_max_chunk = 0;
        self.use_numa_affinity = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfigProto_Experimental {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigProto_Experimental {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RunOptions {
    // message fields
    pub trace_level: RunOptions_TraceLevel,
    pub timeout_in_ms: i64,
    pub inter_op_thread_pool: i32,
    pub output_partition_graphs: bool,
    pub debug_options: ::protobuf::SingularPtrField<super::debug::DebugOptions>,
    pub report_tensor_allocations_upon_oom: bool,
    pub experimental: ::protobuf::SingularPtrField<RunOptions_Experimental>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RunOptions {
    fn default() -> &'a RunOptions {
        <RunOptions as ::protobuf::Message>::default_instance()
    }
}

impl RunOptions {
    pub fn new() -> RunOptions {
        ::std::default::Default::default()
    }

    // .tensorflow.RunOptions.TraceLevel trace_level = 1;


    pub fn get_trace_level(&self) -> RunOptions_TraceLevel {
        self.trace_level
    }
    pub fn clear_trace_level(&mut self) {
        self.trace_level = RunOptions_TraceLevel::NO_TRACE;
    }

    // Param is passed by value, moved
    pub fn set_trace_level(&mut self, v: RunOptions_TraceLevel) {
        self.trace_level = v;
    }

    // int64 timeout_in_ms = 2;


    pub fn get_timeout_in_ms(&self) -> i64 {
        self.timeout_in_ms
    }
    pub fn clear_timeout_in_ms(&mut self) {
        self.timeout_in_ms = 0;
    }

    // Param is passed by value, moved
    pub fn set_timeout_in_ms(&mut self, v: i64) {
        self.timeout_in_ms = v;
    }

    // int32 inter_op_thread_pool = 3;


    pub fn get_inter_op_thread_pool(&self) -> i32 {
        self.inter_op_thread_pool
    }
    pub fn clear_inter_op_thread_pool(&mut self) {
        self.inter_op_thread_pool = 0;
    }

    // Param is passed by value, moved
    pub fn set_inter_op_thread_pool(&mut self, v: i32) {
        self.inter_op_thread_pool = v;
    }

    // bool output_partition_graphs = 5;


    pub fn get_output_partition_graphs(&self) -> bool {
        self.output_partition_graphs
    }
    pub fn clear_output_partition_graphs(&mut self) {
        self.output_partition_graphs = false;
    }

    // Param is passed by value, moved
    pub fn set_output_partition_graphs(&mut self, v: bool) {
        self.output_partition_graphs = v;
    }

    // .tensorflow.DebugOptions debug_options = 6;


    pub fn get_debug_options(&self) -> &super::debug::DebugOptions {
        self.debug_options.as_ref().unwrap_or_else(|| super::debug::DebugOptions::default_instance())
    }
    pub fn clear_debug_options(&mut self) {
        self.debug_options.clear();
    }

    pub fn has_debug_options(&self) -> bool {
        self.debug_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug_options(&mut self, v: super::debug::DebugOptions) {
        self.debug_options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_debug_options(&mut self) -> &mut super::debug::DebugOptions {
        if self.debug_options.is_none() {
            self.debug_options.set_default();
        }
        self.debug_options.as_mut().unwrap()
    }

    // Take field
    pub fn take_debug_options(&mut self) -> super::debug::DebugOptions {
        self.debug_options.take().unwrap_or_else(|| super::debug::DebugOptions::new())
    }

    // bool report_tensor_allocations_upon_oom = 7;


    pub fn get_report_tensor_allocations_upon_oom(&self) -> bool {
        self.report_tensor_allocations_upon_oom
    }
    pub fn clear_report_tensor_allocations_upon_oom(&mut self) {
        self.report_tensor_allocations_upon_oom = false;
    }

    // Param is passed by value, moved
    pub fn set_report_tensor_allocations_upon_oom(&mut self, v: bool) {
        self.report_tensor_allocations_upon_oom = v;
    }

    // .tensorflow.RunOptions.Experimental experimental = 8;


    pub fn get_experimental(&self) -> &RunOptions_Experimental {
        self.experimental.as_ref().unwrap_or_else(|| RunOptions_Experimental::default_instance())
    }
    pub fn clear_experimental(&mut self) {
        self.experimental.clear();
    }

    pub fn has_experimental(&self) -> bool {
        self.experimental.is_some()
    }

    // Param is passed by value, moved
    pub fn set_experimental(&mut self, v: RunOptions_Experimental) {
        self.experimental = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_experimental(&mut self) -> &mut RunOptions_Experimental {
        if self.experimental.is_none() {
            self.experimental.set_default();
        }
        self.experimental.as_mut().unwrap()
    }

    // Take field
    pub fn take_experimental(&mut self) -> RunOptions_Experimental {
        self.experimental.take().unwrap_or_else(|| RunOptions_Experimental::new())
    }
}

impl ::protobuf::Message for RunOptions {
    fn is_initialized(&self) -> bool {
        for v in &self.debug_options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.experimental {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.trace_level, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timeout_in_ms = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.inter_op_thread_pool = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.output_partition_graphs = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.debug_options)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.report_tensor_allocations_upon_oom = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.experimental)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.trace_level != RunOptions_TraceLevel::NO_TRACE {
            my_size += ::protobuf::rt::enum_size(1, self.trace_level);
        }
        if self.timeout_in_ms != 0 {
            my_size += ::protobuf::rt::value_size(2, self.timeout_in_ms, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.inter_op_thread_pool != 0 {
            my_size += ::protobuf::rt::value_size(3, self.inter_op_thread_pool, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.output_partition_graphs != false {
            my_size += 2;
        }
        if let Some(ref v) = self.debug_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.report_tensor_allocations_upon_oom != false {
            my_size += 2;
        }
        if let Some(ref v) = self.experimental.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.trace_level != RunOptions_TraceLevel::NO_TRACE {
            os.write_enum(1, self.trace_level.value())?;
        }
        if self.timeout_in_ms != 0 {
            os.write_int64(2, self.timeout_in_ms)?;
        }
        if self.inter_op_thread_pool != 0 {
            os.write_int32(3, self.inter_op_thread_pool)?;
        }
        if self.output_partition_graphs != false {
            os.write_bool(5, self.output_partition_graphs)?;
        }
        if let Some(ref v) = self.debug_options.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.report_tensor_allocations_upon_oom != false {
            os.write_bool(7, self.report_tensor_allocations_upon_oom)?;
        }
        if let Some(ref v) = self.experimental.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RunOptions {
        RunOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RunOptions_TraceLevel>>(
                    "trace_level",
                    |m: &RunOptions| { &m.trace_level },
                    |m: &mut RunOptions| { &mut m.trace_level },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "timeout_in_ms",
                    |m: &RunOptions| { &m.timeout_in_ms },
                    |m: &mut RunOptions| { &mut m.timeout_in_ms },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "inter_op_thread_pool",
                    |m: &RunOptions| { &m.inter_op_thread_pool },
                    |m: &mut RunOptions| { &mut m.inter_op_thread_pool },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "output_partition_graphs",
                    |m: &RunOptions| { &m.output_partition_graphs },
                    |m: &mut RunOptions| { &mut m.output_partition_graphs },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::debug::DebugOptions>>(
                    "debug_options",
                    |m: &RunOptions| { &m.debug_options },
                    |m: &mut RunOptions| { &mut m.debug_options },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "report_tensor_allocations_upon_oom",
                    |m: &RunOptions| { &m.report_tensor_allocations_upon_oom },
                    |m: &mut RunOptions| { &mut m.report_tensor_allocations_upon_oom },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RunOptions_Experimental>>(
                    "experimental",
                    |m: &RunOptions| { &m.experimental },
                    |m: &mut RunOptions| { &mut m.experimental },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RunOptions>(
                    "RunOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RunOptions {
        static mut instance: ::protobuf::lazy::Lazy<RunOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RunOptions,
        };
        unsafe {
            instance.get(RunOptions::new)
        }
    }
}

impl ::protobuf::Clear for RunOptions {
    fn clear(&mut self) {
        self.trace_level = RunOptions_TraceLevel::NO_TRACE;
        self.timeout_in_ms = 0;
        self.inter_op_thread_pool = 0;
        self.output_partition_graphs = false;
        self.debug_options.clear();
        self.report_tensor_allocations_upon_oom = false;
        self.experimental.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RunOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RunOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RunOptions_Experimental {
    // message fields
    pub collective_graph_key: i64,
    pub use_run_handler_pool: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RunOptions_Experimental {
    fn default() -> &'a RunOptions_Experimental {
        <RunOptions_Experimental as ::protobuf::Message>::default_instance()
    }
}

impl RunOptions_Experimental {
    pub fn new() -> RunOptions_Experimental {
        ::std::default::Default::default()
    }

    // int64 collective_graph_key = 1;


    pub fn get_collective_graph_key(&self) -> i64 {
        self.collective_graph_key
    }
    pub fn clear_collective_graph_key(&mut self) {
        self.collective_graph_key = 0;
    }

    // Param is passed by value, moved
    pub fn set_collective_graph_key(&mut self, v: i64) {
        self.collective_graph_key = v;
    }

    // bool use_run_handler_pool = 2;


    pub fn get_use_run_handler_pool(&self) -> bool {
        self.use_run_handler_pool
    }
    pub fn clear_use_run_handler_pool(&mut self) {
        self.use_run_handler_pool = false;
    }

    // Param is passed by value, moved
    pub fn set_use_run_handler_pool(&mut self, v: bool) {
        self.use_run_handler_pool = v;
    }
}

impl ::protobuf::Message for RunOptions_Experimental {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.collective_graph_key = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_run_handler_pool = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.collective_graph_key != 0 {
            my_size += ::protobuf::rt::value_size(1, self.collective_graph_key, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.use_run_handler_pool != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.collective_graph_key != 0 {
            os.write_int64(1, self.collective_graph_key)?;
        }
        if self.use_run_handler_pool != false {
            os.write_bool(2, self.use_run_handler_pool)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RunOptions_Experimental {
        RunOptions_Experimental::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "collective_graph_key",
                    |m: &RunOptions_Experimental| { &m.collective_graph_key },
                    |m: &mut RunOptions_Experimental| { &mut m.collective_graph_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "use_run_handler_pool",
                    |m: &RunOptions_Experimental| { &m.use_run_handler_pool },
                    |m: &mut RunOptions_Experimental| { &mut m.use_run_handler_pool },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RunOptions_Experimental>(
                    "RunOptions_Experimental",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RunOptions_Experimental {
        static mut instance: ::protobuf::lazy::Lazy<RunOptions_Experimental> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RunOptions_Experimental,
        };
        unsafe {
            instance.get(RunOptions_Experimental::new)
        }
    }
}

impl ::protobuf::Clear for RunOptions_Experimental {
    fn clear(&mut self) {
        self.collective_graph_key = 0;
        self.use_run_handler_pool = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RunOptions_Experimental {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RunOptions_Experimental {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RunOptions_TraceLevel {
    NO_TRACE = 0,
    SOFTWARE_TRACE = 1,
    HARDWARE_TRACE = 2,
    FULL_TRACE = 3,
}

impl ::protobuf::ProtobufEnum for RunOptions_TraceLevel {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RunOptions_TraceLevel> {
        match value {
            0 => ::std::option::Option::Some(RunOptions_TraceLevel::NO_TRACE),
            1 => ::std::option::Option::Some(RunOptions_TraceLevel::SOFTWARE_TRACE),
            2 => ::std::option::Option::Some(RunOptions_TraceLevel::HARDWARE_TRACE),
            3 => ::std::option::Option::Some(RunOptions_TraceLevel::FULL_TRACE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RunOptions_TraceLevel] = &[
            RunOptions_TraceLevel::NO_TRACE,
            RunOptions_TraceLevel::SOFTWARE_TRACE,
            RunOptions_TraceLevel::HARDWARE_TRACE,
            RunOptions_TraceLevel::FULL_TRACE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("RunOptions_TraceLevel", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for RunOptions_TraceLevel {
}

impl ::std::default::Default for RunOptions_TraceLevel {
    fn default() -> Self {
        RunOptions_TraceLevel::NO_TRACE
    }
}

impl ::protobuf::reflect::ProtobufValue for RunOptions_TraceLevel {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RunMetadata {
    // message fields
    pub step_stats: ::protobuf::SingularPtrField<super::step_stats::StepStats>,
    pub cost_graph: ::protobuf::SingularPtrField<super::cost_graph::CostGraphDef>,
    pub partition_graphs: ::protobuf::RepeatedField<super::graph::GraphDef>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RunMetadata {
    fn default() -> &'a RunMetadata {
        <RunMetadata as ::protobuf::Message>::default_instance()
    }
}

impl RunMetadata {
    pub fn new() -> RunMetadata {
        ::std::default::Default::default()
    }

    // .tensorflow.StepStats step_stats = 1;


    pub fn get_step_stats(&self) -> &super::step_stats::StepStats {
        self.step_stats.as_ref().unwrap_or_else(|| super::step_stats::StepStats::default_instance())
    }
    pub fn clear_step_stats(&mut self) {
        self.step_stats.clear();
    }

    pub fn has_step_stats(&self) -> bool {
        self.step_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_step_stats(&mut self, v: super::step_stats::StepStats) {
        self.step_stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_step_stats(&mut self) -> &mut super::step_stats::StepStats {
        if self.step_stats.is_none() {
            self.step_stats.set_default();
        }
        self.step_stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_step_stats(&mut self) -> super::step_stats::StepStats {
        self.step_stats.take().unwrap_or_else(|| super::step_stats::StepStats::new())
    }

    // .tensorflow.CostGraphDef cost_graph = 2;


    pub fn get_cost_graph(&self) -> &super::cost_graph::CostGraphDef {
        self.cost_graph.as_ref().unwrap_or_else(|| super::cost_graph::CostGraphDef::default_instance())
    }
    pub fn clear_cost_graph(&mut self) {
        self.cost_graph.clear();
    }

    pub fn has_cost_graph(&self) -> bool {
        self.cost_graph.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cost_graph(&mut self, v: super::cost_graph::CostGraphDef) {
        self.cost_graph = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cost_graph(&mut self) -> &mut super::cost_graph::CostGraphDef {
        if self.cost_graph.is_none() {
            self.cost_graph.set_default();
        }
        self.cost_graph.as_mut().unwrap()
    }

    // Take field
    pub fn take_cost_graph(&mut self) -> super::cost_graph::CostGraphDef {
        self.cost_graph.take().unwrap_or_else(|| super::cost_graph::CostGraphDef::new())
    }

    // repeated .tensorflow.GraphDef partition_graphs = 3;


    pub fn get_partition_graphs(&self) -> &[super::graph::GraphDef] {
        &self.partition_graphs
    }
    pub fn clear_partition_graphs(&mut self) {
        self.partition_graphs.clear();
    }

    // Param is passed by value, moved
    pub fn set_partition_graphs(&mut self, v: ::protobuf::RepeatedField<super::graph::GraphDef>) {
        self.partition_graphs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_partition_graphs(&mut self) -> &mut ::protobuf::RepeatedField<super::graph::GraphDef> {
        &mut self.partition_graphs
    }

    // Take field
    pub fn take_partition_graphs(&mut self) -> ::protobuf::RepeatedField<super::graph::GraphDef> {
        ::std::mem::replace(&mut self.partition_graphs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RunMetadata {
    fn is_initialized(&self) -> bool {
        for v in &self.step_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cost_graph {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.partition_graphs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.step_stats)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cost_graph)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.partition_graphs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.step_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cost_graph.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.partition_graphs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.step_stats.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cost_graph.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.partition_graphs {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RunMetadata {
        RunMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::step_stats::StepStats>>(
                    "step_stats",
                    |m: &RunMetadata| { &m.step_stats },
                    |m: &mut RunMetadata| { &mut m.step_stats },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::cost_graph::CostGraphDef>>(
                    "cost_graph",
                    |m: &RunMetadata| { &m.cost_graph },
                    |m: &mut RunMetadata| { &mut m.cost_graph },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::graph::GraphDef>>(
                    "partition_graphs",
                    |m: &RunMetadata| { &m.partition_graphs },
                    |m: &mut RunMetadata| { &mut m.partition_graphs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RunMetadata>(
                    "RunMetadata",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RunMetadata {
        static mut instance: ::protobuf::lazy::Lazy<RunMetadata> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RunMetadata,
        };
        unsafe {
            instance.get(RunMetadata::new)
        }
    }
}

impl ::protobuf::Clear for RunMetadata {
    fn clear(&mut self) {
        self.step_stats.clear();
        self.cost_graph.clear();
        self.partition_graphs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RunMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RunMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TensorConnection {
    // message fields
    pub from_tensor: ::std::string::String,
    pub to_tensor: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TensorConnection {
    fn default() -> &'a TensorConnection {
        <TensorConnection as ::protobuf::Message>::default_instance()
    }
}

impl TensorConnection {
    pub fn new() -> TensorConnection {
        ::std::default::Default::default()
    }

    // string from_tensor = 1;


    pub fn get_from_tensor(&self) -> &str {
        &self.from_tensor
    }
    pub fn clear_from_tensor(&mut self) {
        self.from_tensor.clear();
    }

    // Param is passed by value, moved
    pub fn set_from_tensor(&mut self, v: ::std::string::String) {
        self.from_tensor = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from_tensor(&mut self) -> &mut ::std::string::String {
        &mut self.from_tensor
    }

    // Take field
    pub fn take_from_tensor(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.from_tensor, ::std::string::String::new())
    }

    // string to_tensor = 2;


    pub fn get_to_tensor(&self) -> &str {
        &self.to_tensor
    }
    pub fn clear_to_tensor(&mut self) {
        self.to_tensor.clear();
    }

    // Param is passed by value, moved
    pub fn set_to_tensor(&mut self, v: ::std::string::String) {
        self.to_tensor = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_to_tensor(&mut self) -> &mut ::std::string::String {
        &mut self.to_tensor
    }

    // Take field
    pub fn take_to_tensor(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.to_tensor, ::std::string::String::new())
    }
}

impl ::protobuf::Message for TensorConnection {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.from_tensor)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.to_tensor)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.from_tensor.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.from_tensor);
        }
        if !self.to_tensor.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.to_tensor);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.from_tensor.is_empty() {
            os.write_string(1, &self.from_tensor)?;
        }
        if !self.to_tensor.is_empty() {
            os.write_string(2, &self.to_tensor)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TensorConnection {
        TensorConnection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "from_tensor",
                    |m: &TensorConnection| { &m.from_tensor },
                    |m: &mut TensorConnection| { &mut m.from_tensor },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "to_tensor",
                    |m: &TensorConnection| { &m.to_tensor },
                    |m: &mut TensorConnection| { &mut m.to_tensor },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TensorConnection>(
                    "TensorConnection",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TensorConnection {
        static mut instance: ::protobuf::lazy::Lazy<TensorConnection> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TensorConnection,
        };
        unsafe {
            instance.get(TensorConnection::new)
        }
    }
}

impl ::protobuf::Clear for TensorConnection {
    fn clear(&mut self) {
        self.from_tensor.clear();
        self.to_tensor.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TensorConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TensorConnection {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CallableOptions {
    // message fields
    pub feed: ::protobuf::RepeatedField<::std::string::String>,
    pub fetch: ::protobuf::RepeatedField<::std::string::String>,
    pub target: ::protobuf::RepeatedField<::std::string::String>,
    pub run_options: ::protobuf::SingularPtrField<RunOptions>,
    pub tensor_connection: ::protobuf::RepeatedField<TensorConnection>,
    pub feed_devices: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub fetch_devices: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub fetch_skip_sync: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CallableOptions {
    fn default() -> &'a CallableOptions {
        <CallableOptions as ::protobuf::Message>::default_instance()
    }
}

impl CallableOptions {
    pub fn new() -> CallableOptions {
        ::std::default::Default::default()
    }

    // repeated string feed = 1;


    pub fn get_feed(&self) -> &[::std::string::String] {
        &self.feed
    }
    pub fn clear_feed(&mut self) {
        self.feed.clear();
    }

    // Param is passed by value, moved
    pub fn set_feed(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.feed = v;
    }

    // Mutable pointer to the field.
    pub fn mut_feed(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.feed
    }

    // Take field
    pub fn take_feed(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.feed, ::protobuf::RepeatedField::new())
    }

    // repeated string fetch = 2;


    pub fn get_fetch(&self) -> &[::std::string::String] {
        &self.fetch
    }
    pub fn clear_fetch(&mut self) {
        self.fetch.clear();
    }

    // Param is passed by value, moved
    pub fn set_fetch(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.fetch = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fetch(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.fetch
    }

    // Take field
    pub fn take_fetch(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.fetch, ::protobuf::RepeatedField::new())
    }

    // repeated string target = 3;


    pub fn get_target(&self) -> &[::std::string::String] {
        &self.target
    }
    pub fn clear_target(&mut self) {
        self.target.clear();
    }

    // Param is passed by value, moved
    pub fn set_target(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.target = v;
    }

    // Mutable pointer to the field.
    pub fn mut_target(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.target
    }

    // Take field
    pub fn take_target(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.target, ::protobuf::RepeatedField::new())
    }

    // .tensorflow.RunOptions run_options = 4;


    pub fn get_run_options(&self) -> &RunOptions {
        self.run_options.as_ref().unwrap_or_else(|| RunOptions::default_instance())
    }
    pub fn clear_run_options(&mut self) {
        self.run_options.clear();
    }

    pub fn has_run_options(&self) -> bool {
        self.run_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_run_options(&mut self, v: RunOptions) {
        self.run_options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_run_options(&mut self) -> &mut RunOptions {
        if self.run_options.is_none() {
            self.run_options.set_default();
        }
        self.run_options.as_mut().unwrap()
    }

    // Take field
    pub fn take_run_options(&mut self) -> RunOptions {
        self.run_options.take().unwrap_or_else(|| RunOptions::new())
    }

    // repeated .tensorflow.TensorConnection tensor_connection = 5;


    pub fn get_tensor_connection(&self) -> &[TensorConnection] {
        &self.tensor_connection
    }
    pub fn clear_tensor_connection(&mut self) {
        self.tensor_connection.clear();
    }

    // Param is passed by value, moved
    pub fn set_tensor_connection(&mut self, v: ::protobuf::RepeatedField<TensorConnection>) {
        self.tensor_connection = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tensor_connection(&mut self) -> &mut ::protobuf::RepeatedField<TensorConnection> {
        &mut self.tensor_connection
    }

    // Take field
    pub fn take_tensor_connection(&mut self) -> ::protobuf::RepeatedField<TensorConnection> {
        ::std::mem::replace(&mut self.tensor_connection, ::protobuf::RepeatedField::new())
    }

    // repeated .tensorflow.CallableOptions.FeedDevicesEntry feed_devices = 6;


    pub fn get_feed_devices(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.feed_devices
    }
    pub fn clear_feed_devices(&mut self) {
        self.feed_devices.clear();
    }

    // Param is passed by value, moved
    pub fn set_feed_devices(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.feed_devices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_feed_devices(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.feed_devices
    }

    // Take field
    pub fn take_feed_devices(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.feed_devices, ::std::collections::HashMap::new())
    }

    // repeated .tensorflow.CallableOptions.FetchDevicesEntry fetch_devices = 7;


    pub fn get_fetch_devices(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.fetch_devices
    }
    pub fn clear_fetch_devices(&mut self) {
        self.fetch_devices.clear();
    }

    // Param is passed by value, moved
    pub fn set_fetch_devices(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.fetch_devices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fetch_devices(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.fetch_devices
    }

    // Take field
    pub fn take_fetch_devices(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.fetch_devices, ::std::collections::HashMap::new())
    }

    // bool fetch_skip_sync = 8;


    pub fn get_fetch_skip_sync(&self) -> bool {
        self.fetch_skip_sync
    }
    pub fn clear_fetch_skip_sync(&mut self) {
        self.fetch_skip_sync = false;
    }

    // Param is passed by value, moved
    pub fn set_fetch_skip_sync(&mut self, v: bool) {
        self.fetch_skip_sync = v;
    }
}

impl ::protobuf::Message for CallableOptions {
    fn is_initialized(&self) -> bool {
        for v in &self.run_options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tensor_connection {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.feed)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.fetch)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.target)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.run_options)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tensor_connection)?;
                },
                6 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.feed_devices)?;
                },
                7 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.fetch_devices)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.fetch_skip_sync = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.feed {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.fetch {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.target {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if let Some(ref v) = self.run_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.tensor_connection {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(6, &self.feed_devices);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(7, &self.fetch_devices);
        if self.fetch_skip_sync != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.feed {
            os.write_string(1, &v)?;
        };
        for v in &self.fetch {
            os.write_string(2, &v)?;
        };
        for v in &self.target {
            os.write_string(3, &v)?;
        };
        if let Some(ref v) = self.run_options.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.tensor_connection {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(6, &self.feed_devices, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(7, &self.fetch_devices, os)?;
        if self.fetch_skip_sync != false {
            os.write_bool(8, self.fetch_skip_sync)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CallableOptions {
        CallableOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "feed",
                    |m: &CallableOptions| { &m.feed },
                    |m: &mut CallableOptions| { &mut m.feed },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fetch",
                    |m: &CallableOptions| { &m.fetch },
                    |m: &mut CallableOptions| { &mut m.fetch },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "target",
                    |m: &CallableOptions| { &m.target },
                    |m: &mut CallableOptions| { &mut m.target },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RunOptions>>(
                    "run_options",
                    |m: &CallableOptions| { &m.run_options },
                    |m: &mut CallableOptions| { &mut m.run_options },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TensorConnection>>(
                    "tensor_connection",
                    |m: &CallableOptions| { &m.tensor_connection },
                    |m: &mut CallableOptions| { &mut m.tensor_connection },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "feed_devices",
                    |m: &CallableOptions| { &m.feed_devices },
                    |m: &mut CallableOptions| { &mut m.feed_devices },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "fetch_devices",
                    |m: &CallableOptions| { &m.fetch_devices },
                    |m: &mut CallableOptions| { &mut m.fetch_devices },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "fetch_skip_sync",
                    |m: &CallableOptions| { &m.fetch_skip_sync },
                    |m: &mut CallableOptions| { &mut m.fetch_skip_sync },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CallableOptions>(
                    "CallableOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CallableOptions {
        static mut instance: ::protobuf::lazy::Lazy<CallableOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CallableOptions,
        };
        unsafe {
            instance.get(CallableOptions::new)
        }
    }
}

impl ::protobuf::Clear for CallableOptions {
    fn clear(&mut self) {
        self.feed.clear();
        self.fetch.clear();
        self.target.clear();
        self.run_options.clear();
        self.tensor_connection.clear();
        self.feed_devices.clear();
        self.fetch_devices.clear();
        self.fetch_skip_sync = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CallableOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CallableOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n%tensorflow/core/protobuf/config.proto\x12\ntensorflow\x1a*tensorflow/\
    core/framework/cost_graph.proto\x1a%tensorflow/core/framework/graph.prot\
    o\x1a*tensorflow/core/framework/step_stats.proto\x1a$tensorflow/core/pro\
    tobuf/debug.proto\x1a&tensorflow/core/protobuf/cluster.proto\x1a.tensorf\
    low/core/protobuf/rewriter_config.proto\"\xc4\x06\n\nGPUOptions\x12D\n\
    \x1fper_process_gpu_memory_fraction\x18\x01\x20\x01(\x01R\x1bperProcessG\
    puMemoryFraction\x12!\n\x0callow_growth\x18\x04\x20\x01(\x08R\x0ballowGr\
    owth\x12%\n\x0eallocator_type\x18\x02\x20\x01(\tR\rallocatorType\x126\n\
    \x17deferred_deletion_bytes\x18\x03\x20\x01(\x03R\x15deferredDeletionByt\
    es\x12.\n\x13visible_device_list\x18\x05\x20\x01(\tR\x11visibleDeviceLis\
    t\x12;\n\x1apolling_active_delay_usecs\x18\x06\x20\x01(\x05R\x17pollingA\
    ctiveDelayUsecs\x12?\n\x1cpolling_inactive_delay_msecs\x18\x07\x20\x01(\
    \x05R\x19pollingInactiveDelayMsecs\x120\n\x14force_gpu_compatible\x18\
    \x08\x20\x01(\x08R\x12forceGpuCompatible\x12G\n\x0cexperimental\x18\t\
    \x20\x01(\x0b2#.tensorflow.GPUOptions.ExperimentalR\x0cexperimental\x1a\
    \xc4\x02\n\x0cExperimental\x12[\n\x0fvirtual_devices\x18\x01\x20\x03(\
    \x0b22.tensorflow.GPUOptions.Experimental.VirtualDevicesR\x0evirtualDevi\
    ces\x12,\n\x12use_unified_memory\x18\x02\x20\x01(\x08R\x10useUnifiedMemo\
    ry\x12;\n\x1bnum_dev_to_dev_copy_streams\x18\x03\x20\x01(\x05R\x16numDev\
    ToDevCopyStreams\x122\n\x15collective_ring_order\x18\x04\x20\x01(\tR\x13\
    collectiveRingOrder\x1a8\n\x0eVirtualDevices\x12&\n\x0fmemory_limit_mb\
    \x18\x01\x20\x03(\x02R\rmemoryLimitMb\"\x82\x04\n\x10OptimizerOptions\
    \x12M\n#do_common_subexpression_elimination\x18\x01\x20\x01(\x08R\x20doC\
    ommonSubexpressionElimination\x12.\n\x13do_constant_folding\x18\x02\x20\
    \x01(\x08R\x11doConstantFolding\x12>\n\x1cmax_folded_constant_in_bytes\
    \x18\x06\x20\x01(\x03R\x18maxFoldedConstantInBytes\x120\n\x14do_function\
    _inlining\x18\x04\x20\x01(\x08R\x12doFunctionInlining\x12?\n\topt_level\
    \x18\x03\x20\x01(\x0e2\".tensorflow.OptimizerOptions.LevelR\x08optLevel\
    \x12U\n\x10global_jit_level\x18\x05\x20\x01(\x0e2+.tensorflow.OptimizerO\
    ptions.GlobalJitLevelR\x0eglobalJitLevel\"\x20\n\x05Level\x12\x06\n\x02L\
    1\x10\0\x12\x0f\n\x02L0\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\"C\n\
    \x0eGlobalJitLevel\x12\x0b\n\x07DEFAULT\x10\0\x12\x10\n\x03OFF\x10\xff\
    \xff\xff\xff\xff\xff\xff\xff\xff\x01\x12\x08\n\x04ON_1\x10\x01\x12\x08\n\
    \x04ON_2\x10\x02\"\x90\x04\n\x0cGraphOptions\x124\n\x16enable_recv_sched\
    uling\x18\x02\x20\x01(\x08R\x14enableRecvScheduling\x12I\n\x11optimizer_\
    options\x18\x03\x20\x01(\x0b2\x1c.tensorflow.OptimizerOptionsR\x10optimi\
    zerOptions\x12(\n\x10build_cost_model\x18\x04\x20\x01(\x03R\x0ebuildCost\
    Model\x123\n\x16build_cost_model_after\x18\t\x20\x01(\x03R\x13buildCostM\
    odelAfter\x12!\n\x0cinfer_shapes\x18\x05\x20\x01(\x08R\x0binferShapes\
    \x12,\n\x12place_pruned_graph\x18\x06\x20\x01(\x08R\x10placePrunedGraph\
    \x128\n\x18enable_bfloat16_sendrecv\x18\x07\x20\x01(\x08R\x16enableBfloa\
    t16Sendrecv\x12#\n\rtimeline_step\x18\x08\x20\x01(\x05R\x0ctimelineStep\
    \x12C\n\x0frewrite_options\x18\n\x20\x01(\x0b2\x1a.tensorflow.RewriterCo\
    nfigR\x0erewriteOptionsJ\x04\x08\x01\x10\x02R%skip_common_subexpression_\
    elimination\"Y\n\x15ThreadPoolOptionProto\x12\x1f\n\x0bnum_threads\x18\
    \x01\x20\x01(\x05R\nnumThreads\x12\x1f\n\x0bglobal_name\x18\x02\x20\x01(\
    \tR\nglobalName\"\xae\x01\n\nRPCOptions\x12>\n\x1cuse_rpc_for_inprocess_\
    master\x18\x01\x20\x01(\x08R\x18useRpcForInprocessMaster\x123\n\x15compr\
    ession_algorithm\x18\x02\x20\x01(\tR\x14compressionAlgorithm\x12+\n\x11c\
    ompression_level\x18\x03\x20\x01(\x05R\x10compressionLevel\"\xd8\t\n\x0b\
    ConfigProto\x12K\n\x0cdevice_count\x18\x01\x20\x03(\x0b2(.tensorflow.Con\
    figProto.DeviceCountEntryR\x0bdeviceCount\x12?\n\x1cintra_op_parallelism\
    _threads\x18\x02\x20\x01(\x05R\x19intraOpParallelismThreads\x12?\n\x1cin\
    ter_op_parallelism_threads\x18\x05\x20\x01(\x05R\x19interOpParallelismTh\
    reads\x125\n\x17use_per_session_threads\x18\t\x20\x01(\x08R\x14usePerSes\
    sionThreads\x12a\n\x1csession_inter_op_thread_pool\x18\x0c\x20\x03(\x0b2\
    !.tensorflow.ThreadPoolOptionProtoR\x18sessionInterOpThreadPool\x12)\n\
    \x10placement_period\x18\x03\x20\x01(\x05R\x0fplacementPeriod\x12%\n\x0e\
    device_filters\x18\x04\x20\x03(\tR\rdeviceFilters\x127\n\x0bgpu_options\
    \x18\x06\x20\x01(\x0b2\x16.tensorflow.GPUOptionsR\ngpuOptions\x120\n\x14\
    allow_soft_placement\x18\x07\x20\x01(\x08R\x12allowSoftPlacement\x120\n\
    \x14log_device_placement\x18\x08\x20\x01(\x08R\x12logDevicePlacement\x12\
    =\n\rgraph_options\x18\n\x20\x01(\x0b2\x18.tensorflow.GraphOptionsR\x0cg\
    raphOptions\x125\n\x17operation_timeout_in_ms\x18\x0b\x20\x01(\x03R\x14o\
    perationTimeoutInMs\x127\n\x0brpc_options\x18\r\x20\x01(\x0b2\x16.tensor\
    flow.RPCOptionsR\nrpcOptions\x127\n\x0bcluster_def\x18\x0e\x20\x01(\x0b2\
    \x16.tensorflow.ClusterDefR\nclusterDef\x122\n\x15isolate_session_state\
    \x18\x0f\x20\x01(\x08R\x13isolateSessionState\x12H\n\x0cexperimental\x18\
    \x10\x20\x01(\x0b2$.tensorflow.ConfigProto.ExperimentalR\x0cexperimental\
    \x1a>\n\x10DeviceCountEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\x05R\x05value:\x028\x01\x1a\xca\x01\
    \n\x0cExperimental\x126\n\x17collective_group_leader\x18\x01\x20\x01(\tR\
    \x15collectiveGroupLeader\x12#\n\rexecutor_type\x18\x03\x20\x01(\tR\x0ce\
    xecutorType\x12+\n\x12recv_buf_max_chunk\x18\x04\x20\x01(\x05R\x0frecvBu\
    fMaxChunk\x12*\n\x11use_numa_affinity\x18\x05\x20\x01(\x08R\x0fuseNumaAf\
    finityJ\x04\x08\x02\x10\x03\"\xfe\x04\n\nRunOptions\x12B\n\x0btrace_leve\
    l\x18\x01\x20\x01(\x0e2!.tensorflow.RunOptions.TraceLevelR\ntraceLevel\
    \x12\"\n\rtimeout_in_ms\x18\x02\x20\x01(\x03R\x0btimeoutInMs\x12/\n\x14i\
    nter_op_thread_pool\x18\x03\x20\x01(\x05R\x11interOpThreadPool\x126\n\
    \x17output_partition_graphs\x18\x05\x20\x01(\x08R\x15outputPartitionGrap\
    hs\x12=\n\rdebug_options\x18\x06\x20\x01(\x0b2\x18.tensorflow.DebugOptio\
    nsR\x0cdebugOptions\x12J\n\"report_tensor_allocations_upon_oom\x18\x07\
    \x20\x01(\x08R\x1ereportTensorAllocationsUponOom\x12G\n\x0cexperimental\
    \x18\x08\x20\x01(\x0b2#.tensorflow.RunOptions.ExperimentalR\x0cexperimen\
    tal\x1aq\n\x0cExperimental\x120\n\x14collective_graph_key\x18\x01\x20\
    \x01(\x03R\x12collectiveGraphKey\x12/\n\x14use_run_handler_pool\x18\x02\
    \x20\x01(\x08R\x11useRunHandlerPool\"R\n\nTraceLevel\x12\x0c\n\x08NO_TRA\
    CE\x10\0\x12\x12\n\x0eSOFTWARE_TRACE\x10\x01\x12\x12\n\x0eHARDWARE_TRACE\
    \x10\x02\x12\x0e\n\nFULL_TRACE\x10\x03J\x04\x08\x04\x10\x05\"\xbd\x01\n\
    \x0bRunMetadata\x124\n\nstep_stats\x18\x01\x20\x01(\x0b2\x15.tensorflow.\
    StepStatsR\tstepStats\x127\n\ncost_graph\x18\x02\x20\x01(\x0b2\x18.tenso\
    rflow.CostGraphDefR\tcostGraph\x12?\n\x10partition_graphs\x18\x03\x20\
    \x03(\x0b2\x14.tensorflow.GraphDefR\x0fpartitionGraphs\"P\n\x10TensorCon\
    nection\x12\x1f\n\x0bfrom_tensor\x18\x01\x20\x01(\tR\nfromTensor\x12\x1b\
    \n\tto_tensor\x18\x02\x20\x01(\tR\x08toTensor\"\xa5\x04\n\x0fCallableOpt\
    ions\x12\x12\n\x04feed\x18\x01\x20\x03(\tR\x04feed\x12\x14\n\x05fetch\
    \x18\x02\x20\x03(\tR\x05fetch\x12\x16\n\x06target\x18\x03\x20\x03(\tR\
    \x06target\x127\n\x0brun_options\x18\x04\x20\x01(\x0b2\x16.tensorflow.Ru\
    nOptionsR\nrunOptions\x12I\n\x11tensor_connection\x18\x05\x20\x03(\x0b2\
    \x1c.tensorflow.TensorConnectionR\x10tensorConnection\x12O\n\x0cfeed_dev\
    ices\x18\x06\x20\x03(\x0b2,.tensorflow.CallableOptions.FeedDevicesEntryR\
    \x0bfeedDevices\x12R\n\rfetch_devices\x18\x07\x20\x03(\x0b2-.tensorflow.\
    CallableOptions.FetchDevicesEntryR\x0cfetchDevices\x12&\n\x0ffetch_skip_\
    sync\x18\x08\x20\x01(\x08R\rfetchSkipSync\x1a>\n\x10FeedDevicesEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x01(\tR\x05value:\x028\x01\x1a?\n\x11FetchDevicesEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05va\
    lue:\x028\x01B-\n\x18org.tensorflow.frameworkB\x0cConfigProtosP\x01\xf8\
    \x01\x01b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
